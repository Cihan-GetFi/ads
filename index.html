<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <meta name="ad.size" content="width=320,height=480">
    <title>G-Roll - Premium Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #game {
            position: relative;
            width: 100%; height: 100%;
            max-width: 414px;
            margin: 0 auto;
            background: #000;
        }
        #c {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        #loader {
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 24px;
            z-index: 200;
            transition: opacity 0.5s ease-out;
        }
        #loader.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #loader .logo {
            font-size: 64px;
            font-weight: 900;
            background: linear-gradient(135deg, #4CAF50 0%, #8BC34A 50%, #CDDC39 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 6px;
            animation: logoGlow 2s ease-in-out infinite;
        }
        @keyframes logoGlow {
            0%, 100% { filter: drop-shadow(0 0 10px rgba(76, 175, 80, 0.5)); }
            50% { filter: drop-shadow(0 0 20px rgba(76, 175, 80, 0.8)); }
        }
        #loader .progress-bar {
            width: 200px;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            overflow: hidden;
        }
        #loader .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            border-radius: 10px;
            transition: width 0.3s ease-out;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.6);
        }
        #cta {
            display: none;
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.92);
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 24px;
            z-index: 100;
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #cta .logo {
            font-size: 48px;
            font-weight: 900;
            background: linear-gradient(135deg, #4CAF50 0%, #8BC34A 50%, #CDDC39 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 5px;
            filter: drop-shadow(0 4px 20px rgba(76, 175, 80, 0.4));
        }
        #cta .score-container {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 20px 32px;
            background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,160,0,0.1));
            border-radius: 20px;
            border: 2px solid rgba(255,215,0,0.3);
        }
        #cta .score {
            color: #FFD700;
            font-size: 64px;
            font-weight: 900;
            text-shadow: 0 4px 20px rgba(255, 215, 0, 0.6), 0 0 40px rgba(255, 215, 0, 0.3);
            animation: scoreGlow 1.5s ease-in-out infinite;
        }
        @keyframes scoreGlow {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        #cta .coin-icon {
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA000 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            color: #FFA000;
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5);
            animation: coinSpin 3s linear infinite;
        }
        @keyframes coinSpin {
            0%, 100% { transform: rotateY(0deg); }
            50% { transform: rotateY(180deg); }
        }
        #cta .msg {
            color: #fff;
            font-size: 24px;
            font-weight: 600;
            opacity: 0.95;
            text-align: center;
        }
        #cta button {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 50%, #388E3C 100%);
            color: #fff;
            border: none;
            padding: 20px 64px;
            font-size: 24px;
            font-weight: 900;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 40px rgba(76, 175, 80, 0.5);
            animation: ctaPulse 2s infinite ease-in-out;
            text-transform: uppercase;
            letter-spacing: 3px;
            position: relative;
            overflow: hidden;
        }
        #cta button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.2), transparent);
            animation: buttonShine 3s infinite;
        }
        @keyframes buttonShine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }
        #cta button:active {
            transform: scale(0.96);
        }
        @keyframes ctaPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 10px 40px rgba(76, 175, 80, 0.5); }
            50% { transform: scale(1.08); box-shadow: 0 15px 60px rgba(76, 175, 80, 0.7); }
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="game">
        <canvas id="c"></canvas>

        <div id="loader">
            <div class="logo">G-ROLL</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress" style="width: 0%"></div>
            </div>
        </div>

        <div id="cta">
            <div class="logo">G-ROLL</div>
            <div class="score-container">
                <span class="score" id="final-score">0</span>
                <div class="coin-icon">$</div>
            </div>
            <div class="msg">Experience the full adventure!</div>
            <button onclick="handleCTA()">Download Now</button>
        </div>
    </div>

    <script>
    (function() {
        'use strict';

        // ============================================
        // EASING FUNCTIONS
        // ============================================
        const Easing = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeOutQuad: t => t * (2 - t),
            easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            easeInCubic: t => t * t * t,
            easeOutCubic: t => (--t) * t * t + 1,
            easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
            easeOutElastic: t => {
                const c4 = (2 * Math.PI) / 3;
                return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
            },
            easeOutBounce: t => {
                const n1 = 7.5625;
                const d1 = 2.75;
                if (t < 1 / d1) return n1 * t * t;
                else if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
                else if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
                else return n1 * (t -= 2.625 / d1) * t + 0.984375;
            },
            easeInOutBack: t => {
                const c1 = 1.70158;
                const c2 = c1 * 1.525;
                return t < 0.5
                    ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2
                    : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
            }
        };

        // ============================================
        // CONFIGURATION
        // ============================================
        const CFG = {
            WIDTH: 360,
            HEIGHT: 640,
            PIXEL_RATIO: Math.min(window.devicePixelRatio || 1, 2),

            CELL_SIZE: 40,
            GRID_WIDTH: 9,
            PLAYER_START: { x: 4, y: 3 },

            PLAYER_SPEED: 6,
            CAMERA_SPEED: 3.5,
            SWIPE_THRESHOLD: 25,

            GAME_DURATION: 15000,
            TUTORIAL_FADE_SPEED: 2,

            // Enhanced colors
            COLORS: {
                BG_TOP: '#1a1a2e',
                BG_MID: '#16213e',
                BG_BOTTOM: '#0f3460',
                PLAYER: ['#4ade80', '#22c55e', '#16a34a'],
                COIN: ['#fbbf24', '#f59e0b', '#d97706'],
                WALL: ['#ef4444', '#dc2626', '#991b1b'],
                TEXT: '#FFFFFF',
                GRID: 'rgba(255,255,255,0.06)',
                PARTICLE: ['#fbbf24', '#fb923c', '#f472b6']
            },

            PLAYER_RADIUS: 0.4,
            COIN_RADIUS: 0.35,

            IOS_URL: 'https://apps.apple.com/app/g-roll/id6504637900',
            ANDROID_URL: 'https://play.google.com/store/apps/details?id=com.wikzllc.groll'
        };

        // ============================================
        // LEVEL DATA
        // ============================================
        const LEVEL = {
            coins: [
                { x: 4, y: 6 }, { x: 4, y: 9 }, { x: 3, y: 12 }, { x: 5, y: 12 }, { x: 4, y: 15 },
                { x: 2, y: 19 }, { x: 6, y: 19 }, { x: 4, y: 22 }, { x: 3, y: 25 }, { x: 5, y: 25 }, { x: 4, y: 28 },
                { x: 3, y: 34 }, { x: 4, y: 34 }, { x: 5, y: 34 }, { x: 2, y: 38 }, { x: 6, y: 38 }, { x: 4, y: 42 },
                { x: 3, y: 46 }, { x: 5, y: 46 }, { x: 4, y: 50 }
            ],
            walls: [
                { x: 1, y: 10, w: 2, h: 1 }, { x: 6, y: 10, w: 2, h: 1 },
                { x: 0, y: 17, w: 3, h: 1 }, { x: 6, y: 17, w: 3, h: 1 },
                { x: 2, y: 30, w: 2, h: 1 }, { x: 5, y: 32, w: 2, h: 1 },
                { x: 0, y: 40, w: 2, h: 1 }, { x: 7, y: 40, w: 2, h: 1 }
            ]
        };

        // ============================================
        // PARTICLE SYSTEM
        // ============================================
        const ParticleSystem = {
            particles: [],
            pool: [],

            init() {
                // Pre-create particle pool
                for (let i = 0; i < 100; i++) {
                    this.pool.push(this.createParticle());
                }
            },

            createParticle() {
                return {
                    x: 0, y: 0,
                    vx: 0, vy: 0,
                    life: 0, maxLife: 1,
                    size: 4,
                    color: '#fff',
                    alpha: 1,
                    gravity: 0,
                    active: false
                };
            },

            spawn(x, y, config = {}) {
                const p = this.pool.pop() || this.createParticle();

                p.x = x;
                p.y = y;
                p.vx = (config.vx || 0) + (Math.random() - 0.5) * (config.spread || 2);
                p.vy = (config.vy || 0) + (Math.random() - 0.5) * (config.spread || 2);
                p.life = 0;
                p.maxLife = config.life || 1;
                p.size = config.size || 4;
                p.color = config.color || '#fff';
                p.alpha = 1;
                p.gravity = config.gravity || 0;
                p.active = true;

                this.particles.push(p);
            },

            spawnBurst(x, y, count, config) {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count;
                    const speed = config.speed || 3;
                    this.spawn(x, y, {
                        ...config,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed
                    });
                }
            },

            update(dt) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];

                    p.life += dt;
                    if (p.life >= p.maxLife) {
                        p.active = false;
                        this.pool.push(p);
                        this.particles.splice(i, 1);
                        continue;
                    }

                    p.x += p.vx * dt * 60;
                    p.y += p.vy * dt * 60;
                    p.vy += p.gravity * dt * 60;

                    const progress = p.life / p.maxLife;
                    p.alpha = 1 - Easing.easeInQuad(progress);
                    p.size = (config.size || 4) * (1 - Easing.easeOutQuad(progress) * 0.5);
                }
            },

            draw(ctx) {
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.alpha;
                    ctx.fillStyle = p.color;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }
        };

        // ============================================
        // TRAIL SYSTEM
        // ============================================
        const TrailSystem = {
            points: [],
            maxPoints: 15,

            add(x, y) {
                this.points.push({ x, y, life: 1 });
                if (this.points.length > this.maxPoints) {
                    this.points.shift();
                }
            },

            update(dt) {
                this.points.forEach(p => {
                    p.life -= dt * 2.5;
                });
                this.points = this.points.filter(p => p.life > 0);
            },

            draw(ctx, camOffset) {
                if (this.points.length < 2) return;

                ctx.save();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                for (let i = 1; i < this.points.length; i++) {
                    const p1 = this.points[i - 1];
                    const p2 = this.points[i];

                    const alpha = p2.life * 0.6;
                    const width = p2.life * 20;

                    const gradient = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                    gradient.addColorStop(0, `rgba(76, 222, 128, ${alpha * 0.5})`);
                    gradient.addColorStop(1, `rgba(74, 222, 128, ${alpha})`);

                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = width;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(76, 222, 128, 0.5)';

                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }

                ctx.restore();
            }
        };

        // ============================================
        // ADVANCED SPRITE CACHE
        // ============================================
        const SpriteCache = {
            player: null,
            coin: null,
            playerShadow: null,
            coinShadow: null,

            init() {
                this.player = this.createAdvancedBall(CFG.CELL_SIZE * 0.85, CFG.COLORS.PLAYER);
                this.coin = this.createAdvancedCoin(CFG.CELL_SIZE * 0.55);
                this.playerShadow = this.createShadow(CFG.CELL_SIZE * 0.85);
                this.coinShadow = this.createShadow(CFG.CELL_SIZE * 0.55);
            },

            createShadow(size) {
                const canvas = document.createElement('canvas');
                const s = size * CFG.PIXEL_RATIO * 1.2;
                canvas.width = s;
                canvas.height = s / 2;
                const ctx = canvas.getContext('2d');

                const gradient = ctx.createRadialGradient(s / 2, canvas.height / 2, 0, s / 2, canvas.height / 2, s / 2);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)');
                gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.2)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(s / 2, canvas.height / 2, s / 2, canvas.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();

                return canvas;
            },

            createAdvancedBall(size, colors) {
                const canvas = document.createElement('canvas');
                const s = size * CFG.PIXEL_RATIO;
                canvas.width = s;
                canvas.height = s;
                const ctx = canvas.getContext('2d');

                // Main gradient (3-color for depth)
                const mainGradient = ctx.createRadialGradient(
                    s * 0.35, s * 0.35, 0,
                    s * 0.5, s * 0.5, s * 0.5
                );
                mainGradient.addColorStop(0, colors[0]);
                mainGradient.addColorStop(0.6, colors[1]);
                mainGradient.addColorStop(1, colors[2]);

                // Main circle
                ctx.beginPath();
                ctx.arc(s / 2, s / 2, s / 2 - 2, 0, Math.PI * 2);
                ctx.fillStyle = mainGradient;
                ctx.fill();

                // Specular highlight
                const highlightGradient = ctx.createRadialGradient(
                    s * 0.32, s * 0.28, 0,
                    s * 0.32, s * 0.28, s * 0.25
                );
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                highlightGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.4)');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.beginPath();
                ctx.arc(s * 0.32, s * 0.28, s * 0.25, 0, Math.PI * 2);
                ctx.fillStyle = highlightGradient;
                ctx.fill();

                // Secondary highlight
                ctx.beginPath();
                ctx.ellipse(s * 0.65, s * 0.65, s * 0.12, s * 0.08, Math.PI / 4, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fill();

                return canvas;
            },

            createAdvancedCoin(size) {
                const canvas = document.createElement('canvas');
                const s = size * CFG.PIXEL_RATIO;
                canvas.width = s;
                canvas.height = s;
                const ctx = canvas.getContext('2d');

                // Outer rim (3D effect)
                const rimGradient = ctx.createRadialGradient(
                    s / 2, s / 2, s * 0.35,
                    s / 2, s / 2, s / 2
                );
                rimGradient.addColorStop(0, '#d97706');
                rimGradient.addColorStop(0.5, '#f59e0b');
                rimGradient.addColorStop(1, '#b45309');

                ctx.beginPath();
                ctx.arc(s / 2, s / 2, s / 2 - 2, 0, Math.PI * 2);
                ctx.fillStyle = rimGradient;
                ctx.fill();

                // Inner coin face
                const faceGradient = ctx.createRadialGradient(
                    s * 0.4, s * 0.4, 0,
                    s / 2, s / 2, s * 0.42
                );
                faceGradient.addColorStop(0, '#fef08a');
                faceGradient.addColorStop(0.4, '#fbbf24');
                faceGradient.addColorStop(1, '#f59e0b');

                ctx.beginPath();
                ctx.arc(s / 2, s / 2, s * 0.42, 0, Math.PI * 2);
                ctx.fillStyle = faceGradient;
                ctx.fill();

                // Highlight
                const highlightGradient = ctx.createRadialGradient(
                    s * 0.35, s * 0.32, 0,
                    s * 0.35, s * 0.32, s * 0.2
                );
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.beginPath();
                ctx.arc(s * 0.35, s * 0.32, s * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = highlightGradient;
                ctx.fill();

                // Dollar sign
                ctx.fillStyle = '#d97706';
                ctx.strokeStyle = '#d97706';
                ctx.lineWidth = s * 0.03;
                ctx.font = `bold ${s * 0.5}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.strokeText('$', s / 2, s / 2 + s * 0.03);
                ctx.fillText('$', s / 2, s / 2 + s * 0.03);

                return canvas;
            }
        };

        // ============================================
        // INPUT HANDLER
        // ============================================
        const Input = {
            startPos: null,
            pendingDir: null,

            init() {
                const c = document.getElementById('c');
                c.addEventListener('touchstart', this.onStart.bind(this), { passive: false });
                c.addEventListener('touchmove', this.onMove.bind(this), { passive: false });
                c.addEventListener('touchend', this.onEnd.bind(this), { passive: false });
                c.addEventListener('mousedown', this.onStart.bind(this));
                c.addEventListener('mousemove', this.onMove.bind(this));
                c.addEventListener('mouseup', this.onEnd.bind(this));
            },

            getPos(e) {
                const t = e.touches ? e.touches[0] : e;
                return { x: t.clientX, y: t.clientY };
            },

            onStart(e) {
                e.preventDefault();
                this.startPos = this.getPos(e);
                this.pendingDir = null;
            },

            onMove(e) {
                e.preventDefault();
                if (!this.startPos) return;

                const pos = this.getPos(e);
                const dx = pos.x - this.startPos.x;
                const dy = pos.y - this.startPos.y;

                if (Math.abs(dx) < CFG.SWIPE_THRESHOLD && Math.abs(dy) < CFG.SWIPE_THRESHOLD) return;

                if (Math.abs(dx) > Math.abs(dy)) {
                    this.pendingDir = dx > 0 ? 'RIGHT' : 'LEFT';
                } else {
                    this.pendingDir = dy > 0 ? 'DOWN' : 'UP';
                }
            },

            onEnd(e) {
                if (this.pendingDir) {
                    Player.setDirection(this.pendingDir);
                }
                this.startPos = null;
                this.pendingDir = null;
            }
        };

        // ============================================
        // PLAYER
        // ============================================
        const Player = {
            gridX: 4,
            gridY: 3,
            direction: { x: 0, y: 1 },
            scale: 1,
            squashTime: 0,
            trailTimer: 0,

            init() {
                this.gridX = CFG.PLAYER_START.x;
                this.gridY = CFG.PLAYER_START.y;
                this.direction = { x: 0, y: 1 };
                this.scale = 1;
                this.trailTimer = 0;
            },

            setDirection(dir) {
                const dirs = {
                    'UP': { x: 0, y: 1 },
                    'DOWN': { x: 0, y: -1 },
                    'LEFT': { x: -1, y: 0 },
                    'RIGHT': { x: 1, y: 0 }
                };

                const newDir = dirs[dir];
                if (!newDir) return;

                if (newDir.x !== this.direction.x || newDir.y !== this.direction.y) {
                    this.direction = newDir;
                    this.squashTime = 0.15;

                    // Direction change particle burst
                    const pos = this.getWorldPos();
                    const camOffset = Camera.getOffset();
                    ParticleSystem.spawnBurst(
                        pos.x,
                        CFG.HEIGHT - (pos.y - camOffset.y),
                        8,
                        { color: CFG.COLORS.PLAYER[0], size: 3, life: 0.5, speed: 2, spread: 1 }
                    );
                }

                if (Game.state === 'tutorial') {
                    Game.startPlaying();
                }
            },

            update(dt) {
                if (Game.state !== 'playing') return;

                const speed = CFG.PLAYER_SPEED * dt;
                this.gridX += this.direction.x * speed;
                this.gridY += this.direction.y * speed;

                this.gridX = Math.max(0.5, Math.min(CFG.GRID_WIDTH - 0.5, this.gridX));

                if (this.squashTime > 0) {
                    this.squashTime = Math.max(0, this.squashTime - dt);
                }

                // Trail effect
                this.trailTimer += dt;
                if (this.trailTimer > 0.05) {
                    const pos = this.getWorldPos();
                    const camOffset = Camera.getOffset();
                    TrailSystem.add(pos.x, CFG.HEIGHT - (pos.y - camOffset.y));
                    this.trailTimer = 0;
                }
            },

            getWorldPos() {
                return {
                    x: (this.gridX - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2,
                    y: this.gridY * CFG.CELL_SIZE
                };
            }
        };

        // ============================================
        // CAMERA
        // ============================================
        const Camera = {
            y: 0,
            shakeAmount: 0,
            shakeX: 0,
            shakeY: 0,

            init() {
                this.y = Player.gridY - 5;
                this.shakeAmount = 0;
            },

            update(dt) {
                if (Game.state !== 'playing') return;

                const targetY = Player.gridY - 5;
                this.y += (targetY - this.y) * 0.1;
                this.y += CFG.CAMERA_SPEED * dt;

                if (this.shakeAmount > 0) {
                    this.shakeAmount *= 0.9;
                    if (this.shakeAmount < 0.5) this.shakeAmount = 0;

                    this.shakeX = (Math.random() - 0.5) * this.shakeAmount;
                    this.shakeY = (Math.random() - 0.5) * this.shakeAmount;
                } else {
                    this.shakeX = 0;
                    this.shakeY = 0;
                }
            },

            shake(intensity = 15) {
                this.shakeAmount = intensity;
            },

            getOffset() {
                return {
                    x: this.shakeX,
                    y: this.y * CFG.CELL_SIZE + this.shakeY
                };
            }
        };

        // ============================================
        // ENTITIES
        // ============================================
        const Entities = {
            coins: [],
            walls: [],

            init() {
                this.coins = [];
                this.walls = [];

                LEVEL.coins.forEach(c => {
                    this.coins.push({
                        x: c.x, y: c.y,
                        collected: false,
                        scale: 1,
                        alpha: 1,
                        rotation: Math.random() * Math.PI * 2,
                        bobOffset: Math.random() * Math.PI * 2
                    });
                });

                LEVEL.walls.forEach(w => {
                    this.walls.push({
                        x: w.x, y: w.y,
                        w: w.w || 1, h: w.h || 1,
                        active: true
                    });
                });
            },

            update(dt) {
                const time = performance.now() / 1000;

                this.coins.forEach(coin => {
                    if (coin.collected) {
                        coin.scale += dt * 4;
                        coin.alpha -= dt * 3;
                    } else {
                        // Idle bob animation
                        coin.scale = 1 + Math.sin(time * 3 + coin.bobOffset) * 0.15;
                        coin.rotation += dt * 1.5;
                    }
                });

                this.coins = this.coins.filter(c => !c.collected || c.alpha > 0);
            }
        };

        // ============================================
        // COLLISION
        // ============================================
        const Collision = {
            check() {
                if (Game.state !== 'playing') return;

                const px = Player.gridX;
                const py = Player.gridY;

                Entities.coins.forEach(coin => {
                    if (coin.collected) return;

                    const dx = px - coin.x;
                    const dy = py - coin.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < CFG.PLAYER_RADIUS + CFG.COIN_RADIUS) {
                        this.collectCoin(coin);
                    }
                });

                Entities.walls.forEach(wall => {
                    if (!wall.active) return;

                    const pr = CFG.PLAYER_RADIUS;
                    if (px + pr > wall.x &&
                        px - pr < wall.x + wall.w &&
                        py + pr > wall.y &&
                        py - pr < wall.y + wall.h) {
                        this.hitWall();
                    }
                });
            },

            collectCoin(coin) {
                coin.collected = true;
                Game.score++;
                Game.combo++;
                UI.addCoinFX(coin.x, coin.y);

                // Particle burst
                const worldX = (coin.x - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                const camOffset = Camera.getOffset();
                const screenY = CFG.HEIGHT - (coin.y * CFG.CELL_SIZE - camOffset.y);

                ParticleSystem.spawnBurst(worldX, screenY, 12, {
                    color: CFG.COLORS.COIN[0],
                    size: 5,
                    life: 0.8,
                    speed: 4,
                    spread: 2,
                    gravity: 0.15
                });

                Camera.shake(5);
            },

            hitWall() {
                if (Game.state !== 'playing') return;
                Game.state = 'gameover';
                Camera.shake(25);
                Player.squashTime = 0.4;

                // Impact particles
                const pos = Player.getWorldPos();
                const camOffset = Camera.getOffset();
                ParticleSystem.spawnBurst(
                    pos.x,
                    CFG.HEIGHT - (pos.y - camOffset.y),
                    20,
                    { color: '#ef4444', size: 6, life: 1, speed: 5, spread: 3, gravity: 0.2 }
                );

                setTimeout(() => Game.showCTA(), 1200);
            }
        };

        // ============================================
        // UI
        // ============================================
        const UI = {
            tutorialAlpha: 1,
            coinFX: [],

            addCoinFX(gridX, gridY) {
                const worldX = (gridX - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                const camOffset = Camera.getOffset();
                const screenY = CFG.HEIGHT - (gridY * CFG.CELL_SIZE - camOffset.y);

                this.coinFX.push({
                    x: worldX,
                    y: screenY,
                    alpha: 1,
                    scale: 0.5,
                    life: 0
                });
            },

            update(dt) {
                if (Game.state === 'playing' && this.tutorialAlpha > 0) {
                    this.tutorialAlpha = Math.max(0, this.tutorialAlpha - dt * CFG.TUTORIAL_FADE_SPEED);
                }

                this.coinFX = this.coinFX.filter(fx => {
                    fx.life += dt;
                    fx.y -= dt * 80;
                    fx.alpha = 1 - Easing.easeInQuad(fx.life / 0.8);
                    fx.scale = 0.5 + Easing.easeOutBack(Math.min(fx.life / 0.3, 1)) * 0.5;
                    return fx.life < 0.8;
                });
            },

            draw(ctx) {
                // Score with glow
                ctx.save();
                ctx.fillStyle = CFG.COLORS.TEXT;
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'left';
                ctx.shadowColor = 'rgba(74, 222, 128, 0.6)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 2;

                const scoreX = 24;
                const scoreY = 48;
                ctx.fillText(Game.score.toString(), scoreX, scoreY);

                // Coin icon
                const iconSize = 32;
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(251, 191, 36, 0.6)';
                ctx.drawImage(SpriteCache.coin, scoreX + 50, scoreY - 24, iconSize, iconSize);
                ctx.restore();

                // Enhanced timer bar
                const progress = Math.max(0, (CFG.GAME_DURATION - Game.elapsed) / CFG.GAME_DURATION);
                const barX = 24;
                const barY = 68;
                const barW = CFG.WIDTH - 48;
                const barH = 10;

                // Bar background
                ctx.fillStyle = 'rgba(255,255,255,0.15)';
                ctx.beginPath();
                ctx.roundRect(barX, barY, barW, barH, 5);
                ctx.fill();

                // Bar fill with gradient
                const gradient = ctx.createLinearGradient(barX, 0, barX + barW * progress, 0);
                gradient.addColorStop(0, '#4ade80');
                gradient.addColorStop(0.5, '#22c55e');
                gradient.addColorStop(1, '#16a34a');

                ctx.fillStyle = gradient;
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(74, 222, 128, 0.5)';
                ctx.beginPath();
                ctx.roundRect(barX, barY, barW * progress, barH, 5);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Coin FX
                this.coinFX.forEach(fx => {
                    ctx.save();
                    ctx.globalAlpha = fx.alpha;
                    ctx.fillStyle = CFG.COLORS.COIN[0];
                    ctx.font = `bold ${24 * fx.scale}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = CFG.COLORS.COIN[0];
                    ctx.fillText('+1', fx.x, fx.y);
                    ctx.restore();
                });

                // Tutorial
                if (this.tutorialAlpha > 0 && (Game.state === 'tutorial' || Game.state === 'loading')) {
                    this.drawTutorial(ctx);
                }
            },

            drawTutorial(ctx) {
                const alpha = this.tutorialAlpha;

                ctx.fillStyle = `rgba(0,0,0,${0.5 * alpha})`;
                ctx.fillRect(0, 0, CFG.WIDTH, CFG.HEIGHT);

                ctx.globalAlpha = alpha;

                // Title with gradient
                const titleGradient = ctx.createLinearGradient(0, CFG.HEIGHT / 2 - 80, 0, CFG.HEIGHT / 2 - 40);
                titleGradient.addColorStop(0, '#4ade80');
                titleGradient.addColorStop(1, '#22c55e');

                ctx.fillStyle = titleGradient;
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(74, 222, 128, 0.8)';
                ctx.shadowBlur = 20;
                ctx.fillText('Swipe to Move', CFG.WIDTH / 2, CFG.HEIGHT / 2 - 60);

                // Animated hand
                const time = performance.now() / 1000;
                const handX = CFG.WIDTH / 2 + Math.sin(time * 2.5) * 60;
                const handY = CFG.HEIGHT / 2 + 20;

                ctx.strokeStyle = `rgba(255,255,255,${0.6 * alpha})`;
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.setLineDash([12, 8]);
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(255,255,255,0.5)';
                ctx.beginPath();
                ctx.moveTo(CFG.WIDTH / 2 - 70, handY);
                ctx.lineTo(CFG.WIDTH / 2 + 70, handY);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.font = '60px Arial';
                ctx.shadowBlur = 15;
                ctx.fillText('☝️', handX, handY + 10);

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        };

        // ============================================
        // RENDERER
        // ============================================
        const Render = {
            ctx: null,
            canvas: null,

            init() {
                this.canvas = document.getElementById('c');
                this.canvas.width = CFG.WIDTH * CFG.PIXEL_RATIO;
                this.canvas.height = CFG.HEIGHT * CFG.PIXEL_RATIO;
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';

                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.ctx.scale(CFG.PIXEL_RATIO, CFG.PIXEL_RATIO);
            },

            draw() {
                const ctx = this.ctx;
                const camOffset = Camera.getOffset();

                // Enhanced background with 3 colors
                const bgGradient = ctx.createLinearGradient(0, 0, 0, CFG.HEIGHT);
                bgGradient.addColorStop(0, CFG.COLORS.BG_TOP);
                bgGradient.addColorStop(0.5, CFG.COLORS.BG_MID);
                bgGradient.addColorStop(1, CFG.COLORS.BG_BOTTOM);
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, CFG.WIDTH, CFG.HEIGHT);

                // Subtle grid
                ctx.strokeStyle = CFG.COLORS.GRID;
                ctx.lineWidth = 1;

                for (let i = 0; i <= CFG.GRID_WIDTH; i++) {
                    const x = (i - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, CFG.HEIGHT);
                    ctx.stroke();
                }

                const gridOffsetY = camOffset.y % CFG.CELL_SIZE;
                for (let i = -1; i <= CFG.HEIGHT / CFG.CELL_SIZE + 1; i++) {
                    const y = CFG.HEIGHT - i * CFG.CELL_SIZE + gridOffsetY;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(CFG.WIDTH, y);
                    ctx.stroke();
                }

                ctx.save();
                ctx.translate(camOffset.x, 0);

                // Draw shadows first
                this.drawShadows(ctx, camOffset);

                // Draw entities
                this.drawWalls(ctx, camOffset);
                this.drawCoins(ctx, camOffset);

                // Trail behind player
                TrailSystem.draw(ctx, camOffset);

                this.drawPlayer(ctx, camOffset);

                ctx.restore();

                // Particles on top
                ParticleSystem.draw(ctx);

                // UI last
                UI.draw(ctx);
            },

            drawShadows(ctx, camOffset) {
                // Player shadow
                const pos = Player.getWorldPos();
                const shadowSize = CFG.CELL_SIZE * 0.85 * 1.1;
                const shadowY = CFG.HEIGHT - (pos.y - camOffset.y) + CFG.CELL_SIZE * 0.3;

                ctx.globalAlpha = 0.3;
                ctx.drawImage(
                    SpriteCache.playerShadow,
                    pos.x - shadowSize / 2,
                    shadowY - shadowSize / 4,
                    shadowSize,
                    shadowSize / 2
                );

                // Coin shadows
                Entities.coins.forEach(coin => {
                    if (coin.collected) return;
                    const screenY = CFG.HEIGHT - (coin.y * CFG.CELL_SIZE - camOffset.y);
                    if (screenY < -CFG.CELL_SIZE || screenY > CFG.HEIGHT + CFG.CELL_SIZE) return;

                    const x = (coin.x - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                    const size = CFG.CELL_SIZE * 0.55;

                    ctx.drawImage(
                        SpriteCache.coinShadow,
                        x - size / 2,
                        screenY + CFG.CELL_SIZE * 0.15,
                        size,
                        size / 2
                    );
                });

                ctx.globalAlpha = 1;
            },

            drawWalls(ctx, camOffset) {
                Entities.walls.forEach(wall => {
                    const screenY = CFG.HEIGHT - (wall.y * CFG.CELL_SIZE - camOffset.y);
                    if (screenY < -CFG.CELL_SIZE * 2 || screenY > CFG.HEIGHT + CFG.CELL_SIZE * 2) return;

                    const x = (wall.x - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                    const y = wall.y * CFG.CELL_SIZE;
                    const w = wall.w * CFG.CELL_SIZE;
                    const h = wall.h * CFG.CELL_SIZE;

                    // 3-color gradient for depth
                    const wallGradient = ctx.createLinearGradient(
                        x, CFG.HEIGHT - (y - camOffset.y),
                        x, CFG.HEIGHT - (y - camOffset.y) - h
                    );
                    wallGradient.addColorStop(0, CFG.COLORS.WALL[0]);
                    wallGradient.addColorStop(0.5, CFG.COLORS.WALL[1]);
                    wallGradient.addColorStop(1, CFG.COLORS.WALL[2]);

                    // Main wall
                    ctx.fillStyle = wallGradient;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(239, 68, 68, 0.4)';
                    ctx.beginPath();
                    ctx.roundRect(
                        x - w / 2 + 3,
                        CFG.HEIGHT - (y - camOffset.y) - h + 3,
                        w - 6,
                        h - 6,
                        8
                    );
                    ctx.fill();

                    // Highlight
                    const highlightGradient = ctx.createLinearGradient(
                        x, CFG.HEIGHT - (y - camOffset.y) - h + 6,
                        x, CFG.HEIGHT - (y - camOffset.y) - h + 6 + (h - 12) * 0.4
                    );
                    highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                    ctx.fillStyle = highlightGradient;
                    ctx.shadowBlur = 0;
                    ctx.beginPath();
                    ctx.roundRect(
                        x - w / 2 + 8,
                        CFG.HEIGHT - (y - camOffset.y) - h + 8,
                        w - 16,
                        (h - 16) * 0.4,
                        6
                    );
                    ctx.fill();
                });
                ctx.shadowBlur = 0;
            },

            drawCoins(ctx, camOffset) {
                Entities.coins.forEach(coin => {
                    const screenY = CFG.HEIGHT - (coin.y * CFG.CELL_SIZE - camOffset.y);
                    if (screenY < -CFG.CELL_SIZE || screenY > CFG.HEIGHT + CFG.CELL_SIZE) return;

                    const x = (coin.x - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                    const y = coin.y * CFG.CELL_SIZE;
                    const size = CFG.CELL_SIZE * 0.55 * coin.scale;

                    ctx.globalAlpha = coin.alpha;

                    if (!coin.collected) {
                        ctx.shadowColor = CFG.COLORS.COIN[0];
                        ctx.shadowBlur = 20;
                    }

                    ctx.save();
                    ctx.translate(x, CFG.HEIGHT - (y - camOffset.y));
                    ctx.rotate(coin.rotation);
                    ctx.drawImage(SpriteCache.coin, -size / 2, -size / 2, size, size);
                    ctx.restore();

                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                });
            },

            drawPlayer(ctx, camOffset) {
                const pos = Player.getWorldPos();
                const size = CFG.CELL_SIZE * 0.85;

                let scaleX = 1;
                let scaleY = 1;
                if (Player.squashTime > 0) {
                    const t = Player.squashTime / 0.15;
                    if (Player.direction.x !== 0) {
                        scaleX = 1 - t * 0.3;
                        scaleY = 1 + t * 0.2;
                    } else {
                        scaleX = 1 + t * 0.2;
                        scaleY = 1 - t * 0.3;
                    }
                }

                const drawX = pos.x;
                const drawY = CFG.HEIGHT - (pos.y - camOffset.y);

                ctx.save();
                ctx.translate(drawX, drawY);
                ctx.scale(scaleX, scaleY);

                ctx.shadowColor = CFG.COLORS.PLAYER[1];
                ctx.shadowBlur = 25;

                ctx.drawImage(SpriteCache.player, -size / 2, -size / 2, size, size);

                ctx.restore();
            }
        };

        // ============================================
        // GAME CONTROLLER
        // ============================================
        const Game = {
            state: 'loading',
            score: 0,
            combo: 0,
            elapsed: 0,
            lastTime: 0,

            async init() {
                // Simulate loading
                await this.loadAssets();

                SpriteCache.init();
                ParticleSystem.init();
                Render.init();
                Input.init();
                Player.init();
                Camera.init();
                Entities.init();

                this.state = 'tutorial';
                this.score = 0;
                this.combo = 0;
                this.elapsed = 0;
                this.lastTime = performance.now();

                // Hide loader
                document.getElementById('loader').classList.add('hidden');

                requestAnimationFrame(this.loop.bind(this));
            },

            async loadAssets() {
                return new Promise(resolve => {
                    let progress = 0;
                    const interval = setInterval(() => {
                        progress += Math.random() * 0.3;
                        if (progress >= 1) {
                            progress = 1;
                            clearInterval(interval);
                            setTimeout(resolve, 200);
                        }
                        document.getElementById('progress').style.width = (progress * 100) + '%';
                    }, 100);
                });
            },

            startPlaying() {
                this.state = 'playing';
                this.elapsed = 0;
            },

            showCTA() {
                this.state = 'cta';
                document.getElementById('final-score').textContent = this.score;
                document.getElementById('cta').style.display = 'flex';
            },

            loop(time) {
                const dt = Math.min((time - this.lastTime) / 1000, 0.1);
                this.lastTime = time;

                if (this.state === 'playing') {
                    this.elapsed += dt * 1000;

                    if (this.elapsed >= CFG.GAME_DURATION) {
                        this.state = 'success';
                        setTimeout(() => this.showCTA(), 1500);
                    }
                }

                Player.update(dt);
                Camera.update(dt);
                Entities.update(dt);
                ParticleSystem.update(dt);
                TrailSystem.update(dt);
                UI.update(dt);
                Collision.check();

                Render.draw();

                if (this.state !== 'cta') {
                    requestAnimationFrame(this.loop.bind(this));
                }
            }
        };

        // ============================================
        // CTA HANDLER
        // ============================================
        window.handleCTA = function() {
            const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            const url = isIOS ? CFG.IOS_URL : CFG.ANDROID_URL;

            if (typeof mraid !== 'undefined' && mraid.open) {
                mraid.open(url);
            } else {
                window.open(url, '_blank');
            }
        };

        // ============================================
        // START
        // ============================================
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => Game.init());
        } else {
            Game.init();
        }
    })();
    </script>
</body>
</html>
