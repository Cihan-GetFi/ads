<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <meta name="ad.size" content="width=320,height=480">
    <title>G-Roll - Ultra Premium Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            font-family: 'Arial Black', 'Arial Bold', sans-serif;
            background: #000;
        }
        #game {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(ellipse at center, #1a2332 0%, #0a0e1a 70%, #000000 100%);
        }
        #c {
            display: block;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        #loader {
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 40px;
            z-index: 200;
            transition: opacity 0.6s ease-out;
        }
        #loader.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #loader .logo {
            font-size: 82px;
            font-weight: 900;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 25%, #fff59d 50%, #ffed4e 75%, #ffd700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 10px;
            animation: logoShine 3s ease-in-out infinite;
            filter: drop-shadow(0 8px 30px rgba(255, 215, 0, 0.8)) drop-shadow(0 0 60px rgba(255, 215, 0, 0.4));
            text-shadow: 0 0 80px rgba(255, 215, 0, 0.6);
        }
        @keyframes logoShine {
            0%, 100% {
                filter: drop-shadow(0 8px 30px rgba(255, 215, 0, 0.8)) drop-shadow(0 0 60px rgba(255, 215, 0, 0.4));
                transform: scale(1) translateY(0);
            }
            50% {
                filter: drop-shadow(0 12px 40px rgba(255, 215, 0, 1)) drop-shadow(0 0 80px rgba(255, 215, 0, 0.6));
                transform: scale(1.08) translateY(-5px);
            }
        }
        #loader .progress-container {
            width: 280px;
            padding: 6px;
            background: rgba(0,0,0,0.4);
            border-radius: 20px;
            box-shadow: inset 0 4px 8px rgba(0,0,0,0.4), 0 4px 20px rgba(255,255,255,0.1);
        }
        #loader .progress-bar {
            width: 100%;
            height: 14px;
            background: linear-gradient(90deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            border-radius: 14px;
            overflow: hidden;
            position: relative;
        }
        #loader .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88 0%, #00d4ff 50%, #a855f7 100%);
            border-radius: 14px;
            transition: width 0.3s ease-out;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.8), inset 0 2px 4px rgba(255,255,255,0.3);
            animation: progressPulse 1.5s infinite;
            position: relative;
            overflow: hidden;
        }
        #loader .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            animation: progressShimmer 2s infinite;
        }
        @keyframes progressPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.8); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 136, 1), 0 0 50px rgba(0, 212, 255, 0.5); }
        }
        @keyframes progressShimmer {
            0% { left: -100%; }
            100% { left: 200%; }
        }
        #cta {
            display: none;
            position: absolute;
            inset: 0;
            background: radial-gradient(ellipse at center, rgba(10,14,26,0.92) 0%, rgba(0,0,0,0.98) 100%);
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 32px;
            z-index: 100;
            animation: ctaFadeIn 0.5s ease-out;
            backdrop-filter: blur(15px);
        }
        @keyframes ctaFadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        #cta .logo {
            font-size: 64px;
            font-weight: 900;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 8px;
            filter: drop-shadow(0 6px 30px rgba(255, 215, 0, 0.6));
            animation: ctaLogoFloat 4s ease-in-out infinite;
        }
        @keyframes ctaLogoFloat {
            0%, 100% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-12px) scale(1.03); }
        }
        #cta .score-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            padding: 32px 48px;
            background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,160,0,0.15));
            border-radius: 30px;
            border: 3px solid rgba(255,215,0,0.5);
            box-shadow: 0 12px 40px rgba(255, 215, 0, 0.4), inset 0 4px 12px rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
        }
        #cta .score-panel::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            animation: panelShine 4s infinite;
        }
        @keyframes panelShine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }
        #cta .score-label {
            color: rgba(255,255,255,0.7);
            font-size: 18px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #cta .score-container {
            display: flex;
            align-items: center;
            gap: 24px;
        }
        #cta .score {
            color: #FFD700;
            font-size: 84px;
            font-weight: 900;
            text-shadow:
                0 4px 30px rgba(255, 215, 0, 0.8),
                0 0 60px rgba(255, 215, 0, 0.5),
                0 8px 0 rgba(180,140,0,0.3);
            animation: scoreGlow 2s ease-in-out infinite;
            font-family: 'Arial Black', sans-serif;
        }
        @keyframes scoreGlow {
            0%, 100% {
                transform: scale(1);
                filter: brightness(1) drop-shadow(0 0 20px rgba(255,215,0,0.6));
            }
            50% {
                transform: scale(1.12);
                filter: brightness(1.3) drop-shadow(0 0 40px rgba(255,215,0,0.9));
            }
        }
        #cta .coin-icon {
            width: 72px;
            height: 72px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA000 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 42px;
            font-weight: bold;
            color: #B8860B;
            box-shadow:
                0 10px 30px rgba(255, 215, 0, 0.7),
                inset 0 4px 12px rgba(255,255,255,0.4),
                inset 0 -4px 8px rgba(180,140,0,0.4);
            animation: coinRotate 4s linear infinite;
            position: relative;
        }
        #cta .coin-icon::after {
            content: '';
            position: absolute;
            top: 10%;
            left: 15%;
            width: 40%;
            height: 40%;
            background: radial-gradient(ellipse, rgba(255,255,255,0.6), transparent);
            border-radius: 50%;
        }
        @keyframes coinRotate {
            0%, 100% { transform: rotateY(0deg) scale(1); }
            25% { transform: rotateY(90deg) scale(0.85); }
            50% { transform: rotateY(180deg) scale(1); }
            75% { transform: rotateY(270deg) scale(0.85); }
        }
        #cta .msg {
            color: #fff;
            font-size: 28px;
            font-weight: 700;
            text-align: center;
            text-shadow: 0 3px 10px rgba(0,0,0,0.6);
            margin-top: 8px;
        }
        #cta button {
            background: linear-gradient(135deg, #00ff88 0%, #00d4ff 50%, #a855f7 100%);
            color: #fff;
            border: none;
            padding: 24px 72px;
            font-size: 28px;
            font-weight: 900;
            border-radius: 60px;
            cursor: pointer;
            box-shadow:
                0 14px 56px rgba(0, 255, 136, 0.6),
                inset 0 3px 10px rgba(255,255,255,0.3);
            animation: ctaPulse 2.5s infinite ease-in-out;
            text-transform: uppercase;
            letter-spacing: 3px;
            position: relative;
            overflow: hidden;
            border: 3px solid rgba(255,255,255,0.3);
        }
        #cta button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: buttonShine 3.5s infinite;
        }
        @keyframes buttonShine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }
        #cta button:active {
            transform: scale(0.96);
        }
        @keyframes ctaPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 14px 56px rgba(0, 255, 136, 0.6);
            }
            50% {
                transform: scale(1.12);
                box-shadow: 0 20px 80px rgba(0, 255, 136, 0.9), 0 0 60px rgba(0, 212, 255, 0.5);
            }
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="game">
        <canvas id="c"></canvas>

        <div id="loader">
            <div class="logo">G-ROLL</div>
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <div id="cta">
            <div class="logo">G-ROLL</div>
            <div class="score-panel">
                <div class="score-label">Your Score</div>
                <div class="score-container">
                    <span class="score" id="final-score">0</span>
                    <div class="coin-icon">$</div>
                </div>
            </div>
            <div class="msg">Download to unlock all levels!</div>
            <button onclick="handleCTA()">Play Full Game</button>
        </div>
    </div>

    <script>
    (function() {
        'use strict';

        const Easing = {
            easeOutQuad: t => t * (2 - t),
            easeOutCubic: t => (--t) * t * t + 1,
            easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
            easeOutElastic: t => {
                const c4 = (2 * Math.PI) / 3;
                return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
            },
            easeOutBack: t => {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            }
        };

        // ULTRA PREMIUM: Texture Generation Helpers
        const TextureGen = {
            // Simple noise function for texture generation
            noise2D(x, y, seed = 0) {
                const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
                return n - Math.floor(n);
            },

            // Perlin-like noise for organic textures
            smoothNoise(x, y, scale = 1, seed = 0) {
                x *= scale;
                y *= scale;
                const x0 = Math.floor(x);
                const x1 = x0 + 1;
                const y0 = Math.floor(y);
                const y1 = y0 + 1;

                const sx = x - x0;
                const sy = y - y0;

                const n00 = this.noise2D(x0, y0, seed);
                const n10 = this.noise2D(x1, y0, seed);
                const n01 = this.noise2D(x0, y1, seed);
                const n11 = this.noise2D(x1, y1, seed);

                const nx0 = n00 * (1 - sx) + n10 * sx;
                const nx1 = n01 * (1 - sx) + n11 * sx;

                return nx0 * (1 - sy) + nx1 * sy;
            },

            // Multi-octave noise for detailed textures
            fractalNoise(x, y, octaves = 4, persistence = 0.5, scale = 1, seed = 0) {
                let total = 0;
                let frequency = scale;
                let amplitude = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    total += this.smoothNoise(x, y, frequency, seed + i) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= 2;
                }

                return total / maxValue;
            },

            // Generate normal map from height map
            getNormal(x, y, size, getHeight) {
                const eps = 0.5;
                const hL = getHeight(x - eps, y);
                const hR = getHeight(x + eps, y);
                const hD = getHeight(x, y - eps);
                const hU = getHeight(x, y + eps);

                const dx = (hR - hL) / (2 * eps);
                const dy = (hU - hD) / (2 * eps);

                const len = Math.sqrt(dx * dx + dy * dy + 1);
                return { x: -dx / len, y: -dy / len, z: 1 / len };
            }
        };

        const CFG = {
            WIDTH: 720,
            HEIGHT: 1280,
            PIXEL_RATIO: Math.min(window.devicePixelRatio || 1, 8), // ULTRA HIGH RESOLUTION
            CELL_SIZE: 80,
            GRID_WIDTH: 9,
            PLAYER_START: { x: 4, y: 3 },
            PLAYER_SPEED: 6,
            CAMERA_SPEED: 3.5,
            SWIPE_THRESHOLD: 25,
            GAME_DURATION: 15000,
            TUTORIAL_FADE_SPEED: 2,
            COLORS: {
                BG_TOP: '#0a0e1a',
                BG_MID: '#1a2332',
                BG_BOTTOM: '#0f1420',
                PLAYER: ['#00ff88', '#00d4ff', '#0088ff'],
                COIN: ['#ffd700', '#ffb700', '#ff8c00'],
                WALL: ['#ff3366', '#ff1744', '#c41c3b'],
                TEXT: '#FFFFFF',
                GRID: 'rgba(0, 255, 136, 0.08)',
                PARTICLE: ['#ffd700', '#00ff88', '#00d4ff', '#a855f7']
            },
            PLAYER_RADIUS: 0.4,
            COIN_RADIUS: 0.35,
            IOS_URL: 'https://apps.apple.com/app/g-roll/id6504637900',
            ANDROID_URL: 'https://play.google.com/store/apps/details?id=com.wikzllc.groll'
        };

        const LEVEL = {
            coins: [
                { x: 4, y: 6 }, { x: 4, y: 9 }, { x: 3, y: 12 }, { x: 5, y: 12 }, { x: 4, y: 15 },
                { x: 2, y: 19 }, { x: 6, y: 19 }, { x: 4, y: 22 }, { x: 3, y: 25 }, { x: 5, y: 25 }, { x: 4, y: 28 },
                { x: 3, y: 34 }, { x: 4, y: 34 }, { x: 5, y: 34 }, { x: 2, y: 38 }, { x: 6, y: 38 }, { x: 4, y: 42 },
                { x: 3, y: 46 }, { x: 5, y: 46 }, { x: 4, y: 50 }, { x: 4, y: 54 }, { x: 3, y: 58 }, { x: 5, y: 58 }
            ],
            walls: [
                { x: 1, y: 10, w: 2, h: 1 }, { x: 6, y: 10, w: 2, h: 1 },
                { x: 0, y: 17, w: 3, h: 1 }, { x: 6, y: 17, w: 3, h: 1 },
                { x: 2, y: 30, w: 2, h: 1 }, { x: 5, y: 32, w: 2, h: 1 },
                { x: 0, y: 40, w: 2, h: 1 }, { x: 7, y: 40, w: 2, h: 1 }
            ],
            // ðŸ”¥ MOVING WALLS - Horizontal sliding obstacles
            movingWalls: [
                { x: 2, y: 14, w: 2, h: 1, minX: 1, maxX: 6, speed: 1.5, dir: 1 },
                { x: 5, y: 26, w: 2, h: 1, minX: 1, maxX: 6, speed: 2, dir: -1 },
                { x: 3, y: 44, w: 2, h: 1, minX: 0, maxX: 7, speed: 1.8, dir: 1 }
            ],
            // ðŸŽ¯ TURRETS - Stationary enemies that shoot
            turrets: [
                { x: 0.5, y: 20, shootDelay: 2.5, lastShot: 0 },
                { x: 8.5, y: 35, shootDelay: 2.0, lastShot: 0 },
                { x: 0.5, y: 48, shootDelay: 3.0, lastShot: 0 }
            ],
            // âš¡ LASERS - Blinking deadly beams
            lasers: [
                { x: 2, y: 24, w: 5, h: 0.2, onTime: 1.5, offTime: 1.5, timer: 0, active: true },
                { x: 1, y: 52, w: 7, h: 0.2, onTime: 1.0, offTime: 2.0, timer: 0, active: false }
            ]
        };

        const ParticleSystem = {
            particles: [],
            pool: [],

            init() {
                for (let i = 0; i < 80; i++) {
                    this.pool.push(this.createParticle());
                }
            },

            createParticle() {
                return {
                    x: 0, y: 0,
                    vx: 0, vy: 0,
                    life: 0, maxLife: 1,
                    size: 4, initialSize: 4,
                    color: '#fff',
                    alpha: 1,
                    gravity: 0,
                    rotation: 0,
                    rotationSpeed: 0,
                    active: false
                };
            },

            spawn(x, y, config = {}) {
                const p = this.pool.pop() || this.createParticle();
                p.x = x;
                p.y = y;
                p.vx = (config.vx || 0) + (Math.random() - 0.5) * (config.spread || 2);
                p.vy = (config.vy || 0) + (Math.random() - 0.5) * (config.spread || 2);
                p.life = 0;
                p.maxLife = config.life || 1;
                p.size = config.size || 4;
                p.initialSize = p.size;
                p.color = Array.isArray(config.color) ? config.color[Math.floor(Math.random() * config.color.length)] : (config.color || '#fff');
                p.alpha = 1;
                p.gravity = config.gravity || 0;
                p.rotation = Math.random() * Math.PI * 2;
                p.rotationSpeed = (Math.random() - 0.5) * 0.2;
                p.active = true;
                this.particles.push(p);
            },

            spawnBurst(x, y, count, config) {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.3;
                    const speed = (config.speed || 3) * (0.8 + Math.random() * 0.4);
                    this.spawn(x, y, {
                        ...config,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed
                    });
                }
            },

            update(dt) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.life += dt;
                    if (p.life >= p.maxLife) {
                        p.active = false;
                        this.pool.push(p);
                        this.particles.splice(i, 1);
                        continue;
                    }
                    p.x += p.vx * dt * 60;
                    p.y += p.vy * dt * 60;
                    p.vy += p.gravity * dt * 60;
                    p.rotation += p.rotationSpeed;
                    const progress = p.life / p.maxLife;
                    p.alpha = 1 - Easing.easeOutQuad(progress);
                    p.size = p.initialSize * (1 - Easing.easeOutCubic(progress) * 0.3);
                }
            },

            draw(ctx) {
                this.particles.forEach(p => {
                    ctx.save();
                    ctx.globalAlpha = p.alpha * 0.9;
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);

                    // Outer glow
                    const outerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, p.size * 2);
                    outerGlow.addColorStop(0, p.color + 'cc');
                    outerGlow.addColorStop(0.3, p.color + '66');
                    outerGlow.addColorStop(0.6, p.color + '22');
                    outerGlow.addColorStop(1, p.color + '00');

                    ctx.fillStyle = outerGlow;
                    ctx.beginPath();
                    ctx.arc(0, 0, p.size * 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Core particle
                    const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, p.size);
                    coreGradient.addColorStop(0, '#ffffff');
                    coreGradient.addColorStop(0.3, p.color);
                    coreGradient.addColorStop(0.7, p.color + 'dd');
                    coreGradient.addColorStop(1, p.color + '00');

                    ctx.fillStyle = coreGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, p.size, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                });
            }
        };

        const TrailSystem = {
            points: [],
            maxPoints: 12,

            add(x, y) {
                this.points.push({ x, y, life: 1 });
                if (this.points.length > this.maxPoints) {
                    this.points.shift();
                }
            },

            update(dt) {
                this.points.forEach(p => p.life -= dt * 1.8);
                this.points = this.points.filter(p => p.life > 0);
            },

            draw(ctx) {
                if (this.points.length < 2) return;
                ctx.save();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                for (let i = 1; i < this.points.length; i++) {
                    const p1 = this.points[i - 1];
                    const p2 = this.points[i];
                    const alpha = p2.life * 0.8;
                    const width = p2.life * 30;

                    const gradient = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                    gradient.addColorStop(0, `rgba(0, 255, 136, ${alpha * 0.3})`);
                    gradient.addColorStop(0.5, `rgba(0, 212, 255, ${alpha * 0.6})`);
                    gradient.addColorStop(1, `rgba(168, 85, 247, ${alpha})`);

                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = width;
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
                ctx.restore();
            }
        };

        const SpriteCache = {
            player: null,
            coin: null,
            playerShadow: null,
            coinShadow: null,

            init() {
                this.player = this.createUltraBall(CFG.CELL_SIZE * 0.85, CFG.COLORS.PLAYER);
                this.coin = this.createUltraCoin(CFG.CELL_SIZE * 0.55);
                this.playerShadow = this.createShadow(CFG.CELL_SIZE * 0.85);
                this.coinShadow = this.createShadow(CFG.CELL_SIZE * 0.55);
            },

            createShadow(size) {
                const canvas = document.createElement('canvas');
                const s = size * CFG.PIXEL_RATIO * 1.4;
                canvas.width = s;
                canvas.height = s / 2;
                const ctx = canvas.getContext('2d');

                const gradient = ctx.createRadialGradient(s / 2, canvas.height / 2, 0, s / 2, canvas.height / 2, s / 2);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0.6)');
                gradient.addColorStop(0.3, 'rgba(0, 0, 0, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(s / 2, canvas.height / 2, s / 2, canvas.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();

                return canvas;
            },

            createUltraBall(size, colors) {
                const canvas = document.createElement('canvas');
                const s = size * CFG.PIXEL_RATIO * 2.5; // ULTRA HIGH RESOLUTION
                canvas.width = s;
                canvas.height = s;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                const centerX = s / 2;
                const centerY = s / 2;
                const radius = s / 2 - 4;

                // ðŸŒ‘ PHOTOREALISTIC SHADOW SYSTEM
                // Contact shadow (sphere on surface)
                const contactShadow = ctx.createRadialGradient(centerX, s * 0.78, 0, centerX, s * 0.78, radius * 0.7);
                contactShadow.addColorStop(0, 'rgba(0, 0, 0, 0.7)');
                contactShadow.addColorStop(0.4, 'rgba(0, 0, 0, 0.4)');
                contactShadow.addColorStop(0.7, 'rgba(0, 0, 0, 0.15)');
                contactShadow.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = contactShadow;
                ctx.beginPath();
                ctx.ellipse(centerX, s * 0.78, radius * 0.7, radius * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();

                // Ambient occlusion shadow
                const aoShadow = ctx.createRadialGradient(centerX + radius * 0.1, centerY + radius * 0.15, 0, centerX, centerY, radius);
                aoShadow.addColorStop(0, 'rgba(0, 0, 0, 0)');
                aoShadow.addColorStop(0.6, 'rgba(0, 0, 0, 0.15)');
                aoShadow.addColorStop(0.8, 'rgba(0, 0, 0, 0.35)');
                aoShadow.addColorStop(0.95, 'rgba(0, 0, 0, 0.6)');
                aoShadow.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
                ctx.fillStyle = aoShadow;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();

                // ðŸŽ¨ PHOTOREALISTIC BASE - 8-layer gradient with natural color transition
                const mainGradient = ctx.createRadialGradient(centerX * 0.7, centerY * 0.6, 0, centerX, centerY, radius * 1.05);
                mainGradient.addColorStop(0, colors[0]); // Bright core
                mainGradient.addColorStop(0.15, colors[0]);
                mainGradient.addColorStop(0.3, colors[0] + 'f0');
                mainGradient.addColorStop(0.45, colors[1]);
                mainGradient.addColorStop(0.6, colors[1] + 'dd');
                mainGradient.addColorStop(0.75, colors[2]);
                mainGradient.addColorStop(0.88, colors[2] + 'cc');
                mainGradient.addColorStop(0.96, '#001a33');
                mainGradient.addColorStop(1, '#000018');

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fillStyle = mainGradient;
                ctx.shadowBlur = 30;
                ctx.shadowColor = colors[1] + '99';
                ctx.fill();
                ctx.shadowBlur = 0;

                // ðŸŒŸ SUBSURFACE SCATTERING - Multi-layer for realism
                const sssGrad1 = ctx.createRadialGradient(centerX * 0.75, centerY * 0.7, 0, centerX, centerY, radius * 0.65);
                sssGrad1.addColorStop(0, colors[0] + 'ff');
                sssGrad1.addColorStop(0.3, colors[0] + 'aa');
                sssGrad1.addColorStop(0.6, colors[1] + '55');
                sssGrad1.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = sssGrad1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();

                // Secondary SSS layer
                const sssGrad2 = ctx.createRadialGradient(centerX * 0.65, centerY * 0.55, 0, centerX, centerY, radius * 0.5);
                sssGrad2.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                sssGrad2.addColorStop(0.5, colors[0] + '44');
                sssGrad2.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = sssGrad2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';

                // ðŸ” MICRO-TEXTURE OVERLAY using fractal noise
                const imageData = ctx.getImageData(0, 0, s, s);
                const pixels = imageData.data;
                for (let y = 0; y < s; y++) {
                    for (let x = 0; x < s; x++) {
                        const dx = x - centerX;
                        const dy = y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist <= radius) {
                            const idx = (y * s + x) * 4;

                            // Fractal noise for surface texture
                            const noise = TextureGen.fractalNoise(x / s, y / s, 6, 0.6, 8, 42);
                            const textureInfluence = 0.08; // Subtle texture

                            // Apply texture to RGB channels
                            pixels[idx] += (noise - 0.5) * 255 * textureInfluence;
                            pixels[idx + 1] += (noise - 0.5) * 255 * textureInfluence;
                            pixels[idx + 2] += (noise - 0.5) * 255 * textureInfluence;
                        }
                    }
                }
                ctx.putImageData(imageData, 0, 0);

                // âœ¨ PREMIUM SPECULAR HIGHLIGHTS - Multiple layers for photorealism
                // Main specular (brightest, sharp)
                const mainSpec = ctx.createRadialGradient(centerX * 0.68, centerY * 0.55, 0, centerX * 0.68, centerY * 0.55, radius * 0.42);
                mainSpec.addColorStop(0, 'rgba(255, 255, 255, 1)');
                mainSpec.addColorStop(0.1, 'rgba(255, 255, 255, 1)');
                mainSpec.addColorStop(0.25, 'rgba(255, 255, 255, 0.95)');
                mainSpec.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
                mainSpec.addColorStop(0.75, 'rgba(255, 255, 255, 0.15)');
                mainSpec.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = mainSpec;
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(centerX * 0.68, centerY * 0.55, radius * 0.42, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Secondary specular highlights (smaller, softer)
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2 + Math.PI / 4;
                    const dist = radius * (0.6 + i * 0.05);
                    const hx = centerX + Math.cos(angle) * dist * 0.7;
                    const hy = centerY + Math.sin(angle) * dist * 0.7;
                    const hr = radius * (0.08 + i * 0.02);

                    const secSpec = ctx.createRadialGradient(hx, hy, 0, hx, hy, hr);
                    secSpec.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                    secSpec.addColorStop(0.5, 'rgba(255, 255, 255, 0.25)');
                    secSpec.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = secSpec;
                    ctx.beginPath();
                    ctx.arc(hx, hy, hr, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ðŸŒˆ ADVANCED RIM LIGHTING - Fresnel effect with color
                const rimGrad1 = ctx.createRadialGradient(centerX, centerY, radius * 0.75, centerX, centerY, radius);
                rimGrad1.addColorStop(0, 'rgba(255, 255, 255, 0)');
                rimGrad1.addColorStop(0.7, 'rgba(255, 255, 255, 0)');
                rimGrad1.addColorStop(0.85, colors[0] + 'dd');
                rimGrad1.addColorStop(0.95, colors[1] + 'aa');
                rimGrad1.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                ctx.fillStyle = rimGrad1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();

                // Outer rim glow
                const rimGrad2 = ctx.createRadialGradient(centerX, centerY, radius * 0.92, centerX, centerY, radius * 1.08);
                rimGrad2.addColorStop(0, 'rgba(255, 255, 255, 0)');
                rimGrad2.addColorStop(0.3, colors[0] + '66');
                rimGrad2.addColorStop(0.7, colors[1] + '44');
                rimGrad2.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = rimGrad2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * 1.08, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';

                // ðŸ’Ž ULTRA GLOSS - Wet surface reflection
                ctx.save();
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.clip();

                ctx.globalCompositeOperation = 'overlay';
                ctx.beginPath();
                ctx.ellipse(centerX * 0.75, centerY * 0.65, radius * 0.5, radius * 0.32, -0.5, 0, Math.PI * 2);
                const gloss1 = ctx.createRadialGradient(centerX * 0.75, centerY * 0.65, 0, centerX * 0.75, centerY * 0.65, radius * 0.5);
                gloss1.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                gloss1.addColorStop(0.3, 'rgba(255, 255, 255, 0.6)');
                gloss1.addColorStop(0.6, 'rgba(255, 255, 255, 0.2)');
                gloss1.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gloss1;
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
                ctx.restore();

                // ðŸ”² CHROMATIC ABERRATION on edges
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.globalAlpha = 0.15;

                // Red channel shift
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(centerX + 1, centerY, radius - 2, 0, Math.PI * 2);
                ctx.stroke();

                // Blue channel shift
                ctx.strokeStyle = '#0000ff';
                ctx.beginPath();
                ctx.arc(centerX - 1, centerY, radius - 2, 0, Math.PI * 2);
                ctx.stroke();

                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 1;
                ctx.restore();

                // Final edge definition
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius - 1, 0, Math.PI * 2);
                ctx.stroke();

                return canvas;
            },

            createUltraCoin(size) {
                const canvas = document.createElement('canvas');
                const s = size * CFG.PIXEL_RATIO * 1.5; // Higher resolution
                canvas.width = s;
                canvas.height = s;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // 3D ISOMETRIC: Coin edge depth layers
                const edgeThickness = 12;
                const tiltAngle = 0.15; // Slight tilt for 3D effect

                // Shadow base (more pronounced for 3D)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.ellipse(s * 0.52, s * 0.58, s * 0.46, s * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();

                // 3D Edge layers (bottom to top)
                for (let i = edgeThickness; i >= 0; i--) {
                    const progress = i / edgeThickness;
                    const yOffset = i * 0.8;

                    // Edge gradient (darker at bottom, lighter at top)
                    const edgeGrad = ctx.createLinearGradient(0, s / 2 + yOffset - edgeThickness, 0, s / 2 + yOffset);
                    edgeGrad.addColorStop(0, '#5a4509');
                    edgeGrad.addColorStop(0.3, '#8b6914');
                    edgeGrad.addColorStop(0.6, '#b8860b');
                    edgeGrad.addColorStop(1, '#daa520');

                    ctx.fillStyle = edgeGrad;
                    ctx.beginPath();
                    ctx.ellipse(s / 2, s / 2 + yOffset, s / 2 - 2, (s / 2 - 2) * 0.85, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Outer ring - multi-layer metallic gold
                const outerGradient = ctx.createRadialGradient(s / 2, s / 2, s * 0.2, s / 2, s / 2, s / 2);
                outerGradient.addColorStop(0, '#725a1a');
                outerGradient.addColorStop(0.2, '#ffd700');
                outerGradient.addColorStop(0.35, '#ffed4e');
                outerGradient.addColorStop(0.5, '#daa520');
                outerGradient.addColorStop(0.65, '#ffd700');
                outerGradient.addColorStop(0.8, '#ffed4e');
                outerGradient.addColorStop(1, '#5a4a0a');

                ctx.beginPath();
                ctx.arc(s / 2, s / 2, s / 2 - 2, 0, Math.PI * 2);
                ctx.fillStyle = outerGradient;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffd700';
                ctx.fill();
                ctx.shadowBlur = 0;

                // Embossed ring detail
                ctx.strokeStyle = 'rgba(139, 105, 20, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(s / 2, s / 2, s * 0.44, 0, Math.PI * 2);
                ctx.stroke();

                // Inner face - ultra bright gold with texture
                const faceGradient = ctx.createRadialGradient(s * 0.3, s * 0.28, 0, s / 2, s / 2, s * 0.44);
                faceGradient.addColorStop(0, '#fffef0');
                faceGradient.addColorStop(0.15, '#fff8dc');
                faceGradient.addColorStop(0.35, '#ffd700');
                faceGradient.addColorStop(0.6, '#ffb700');
                faceGradient.addColorStop(0.85, '#ff9900');
                faceGradient.addColorStop(1, '#cc7700');

                ctx.beginPath();
                ctx.arc(s / 2, s / 2, s * 0.44, 0, Math.PI * 2);
                ctx.fillStyle = faceGradient;
                ctx.fill();

                // Circular brushed metal texture simulation
                ctx.save();
                ctx.globalAlpha = 0.08;
                for (let i = 0; i < 40; i++) {
                    const angle = (i / 40) * Math.PI * 2;
                    ctx.strokeStyle = i % 2 === 0 ? '#fff' : '#000';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(s / 2, s / 2);
                    ctx.lineTo(s / 2 + Math.cos(angle) * s * 0.43, s / 2 + Math.sin(angle) * s * 0.43);
                    ctx.stroke();
                }
                ctx.restore();

                // Large specular highlight (ultra bright)
                const highlightGradient = ctx.createRadialGradient(s * 0.28, s * 0.22, 0, s * 0.28, s * 0.22, s * 0.3);
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                highlightGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');
                highlightGradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.3)');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.beginPath();
                ctx.arc(s * 0.28, s * 0.22, s * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = highlightGradient;
                ctx.fill();

                // Secondary highlight
                ctx.beginPath();
                ctx.ellipse(s * 0.7, s * 0.65, s * 0.12, s * 0.08, Math.PI / 4, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fill();

                // Rim shine
                const rimGrad = ctx.createRadialGradient(s / 2, s / 2, s * 0.38, s / 2, s / 2, s * 0.44);
                rimGrad.addColorStop(0, 'rgba(255, 255, 255, 0)');
                rimGrad.addColorStop(0.85, 'rgba(255, 255, 255, 0)');
                rimGrad.addColorStop(0.95, 'rgba(255, 237, 78, 0.6)');
                rimGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = rimGrad;
                ctx.beginPath();
                ctx.arc(s / 2, s / 2, s * 0.44, 0, Math.PI * 2);
                ctx.fill();

                // Dollar sign - ultra embossed effect
                ctx.save();
                ctx.shadowBlur = 3;
                ctx.shadowColor = 'rgba(0,0,0,0.6)';
                ctx.shadowOffsetY = 3;
                ctx.shadowOffsetX = 1;
                ctx.fillStyle = '#8b6914';
                ctx.strokeStyle = '#5a4509';
                ctx.lineWidth = s * 0.03;
                ctx.font = `900 ${s * 0.5}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.strokeText('$', s / 2, s / 2 + s * 0.04);
                ctx.fillText('$', s / 2, s / 2 + s * 0.04);

                // Dollar sign highlight
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#daa520';
                ctx.font = `900 ${s * 0.5}px Arial`;
                ctx.fillText('$', s / 2 - 1, s / 2 + s * 0.04 - 2);
                ctx.restore();

                return canvas;
            }
        };

        const Input = {
            startPos: null,
            pendingDir: null,
            keysPressed: {},

            init() {
                const c = document.getElementById('c');
                c.addEventListener('touchstart', this.onStart.bind(this), { passive: false });
                c.addEventListener('touchmove', this.onMove.bind(this), { passive: false });
                c.addEventListener('touchend', this.onEnd.bind(this), { passive: false });
                c.addEventListener('mousedown', this.onStart.bind(this));
                c.addEventListener('mousemove', this.onMove.bind(this));
                c.addEventListener('mouseup', this.onEnd.bind(this));

                // Keyboard support
                document.addEventListener('keydown', this.onKeyDown.bind(this));
                document.addEventListener('keyup', this.onKeyUp.bind(this));
            },

            onKeyDown(e) {
                if (this.keysPressed[e.key]) return; // Prevent repeat
                this.keysPressed[e.key] = true;

                let dir = null;
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                    dir = 'UP';
                } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                    dir = 'DOWN';
                } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                    dir = 'LEFT';
                } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                    dir = 'RIGHT';
                }

                if (dir) {
                    e.preventDefault();
                    Player.setDirection(dir);
                }
            },

            onKeyUp(e) {
                this.keysPressed[e.key] = false;
            },

            getPos(e) {
                const t = e.touches ? e.touches[0] : e;
                return { x: t.clientX, y: t.clientY };
            },

            onStart(e) {
                e.preventDefault();
                this.startPos = this.getPos(e);
                this.pendingDir = null;
            },

            onMove(e) {
                e.preventDefault();
                if (!this.startPos) return;

                const pos = this.getPos(e);
                const dx = pos.x - this.startPos.x;
                const dy = pos.y - this.startPos.y;

                if (Math.abs(dx) < CFG.SWIPE_THRESHOLD && Math.abs(dy) < CFG.SWIPE_THRESHOLD) return;

                if (Math.abs(dx) > Math.abs(dy)) {
                    this.pendingDir = dx > 0 ? 'RIGHT' : 'LEFT';
                } else {
                    this.pendingDir = dy > 0 ? 'DOWN' : 'UP';
                }
            },

            onEnd(e) {
                if (this.pendingDir) {
                    Player.setDirection(this.pendingDir);
                }
                this.startPos = null;
                this.pendingDir = null;
            }
        };

        const Player = {
            gridX: 4,
            gridY: 3,
            direction: { x: 0, y: -1 }, // CHANGED: Start moving DOWN
            rotation: 0, // NEW: Rolling animation
            scale: 1,
            squashTime: 0,
            trailTimer: 0,
            deathAnimation: 0,
            deathFragments: [],

            init() {
                this.gridX = CFG.PLAYER_START.x;
                this.gridY = CFG.PLAYER_START.y;
                this.direction = { x: 0, y: -1 }; // CHANGED: Move down by default
                this.rotation = 0;
                this.scale = 1;
                this.trailTimer = 0;
                this.deathAnimation = 0;
                this.deathFragments = [];
            },

            setDirection(dir) {
                const dirs = {
                    'UP': { x: 0, y: -1 },    // REVERSED: UP = move down (map scrolls down)
                    'DOWN': { x: 0, y: 1 },   // REVERSED: DOWN = move up
                    'LEFT': { x: -1, y: 0 },
                    'RIGHT': { x: 1, y: 0 }
                };

                const newDir = dirs[dir];
                if (!newDir) return;

                if (newDir.x !== this.direction.x || newDir.y !== this.direction.y) {
                    this.direction = newDir;
                    this.squashTime = 0.15;

                    const pos = this.getWorldPos();
                    const camOffset = Camera.getOffset();
                    ParticleSystem.spawnBurst(
                        pos.x,
                        CFG.HEIGHT - (pos.y - camOffset.y),
                        12,
                        { color: CFG.COLORS.PARTICLE, size: 5, life: 0.7, speed: 3, spread: 2 }
                    );
                }

                if (Game.state === 'tutorial') {
                    Game.startPlaying();
                }
            },

            update(dt) {
                // Update death animation
                if (this.deathAnimation > 0) {
                    this.deathAnimation = Math.min(1, this.deathAnimation + dt * 2);

                    // Update death fragments
                    this.deathFragments.forEach(frag => {
                        frag.x += frag.vx * dt * 60;
                        frag.y += frag.vy * dt * 60;
                        frag.vy += 0.3; // gravity
                        frag.rotation += frag.rotSpeed * dt;
                        frag.alpha = Math.max(0, 1 - this.deathAnimation);
                    });
                    return;
                }

                if (Game.state !== 'playing') return;

                const speed = CFG.PLAYER_SPEED * dt;
                this.gridX += this.direction.x * speed;
                this.gridY += this.direction.y * speed;

                this.gridX = Math.max(0.5, Math.min(CFG.GRID_WIDTH - 0.5, this.gridX));

                // ðŸŽ¾ ROLLING ANIMATION - Ball rotates as it moves
                const moveSpeed = Math.sqrt(
                    this.direction.x * this.direction.x +
                    this.direction.y * this.direction.y
                ) * speed;
                this.rotation += moveSpeed * 8; // Rotation speed based on movement

                if (this.squashTime > 0) {
                    this.squashTime = Math.max(0, this.squashTime - dt);
                }

                this.trailTimer += dt;
                if (this.trailTimer > 0.035) {
                    const pos = this.getWorldPos();
                    const camOffset = Camera.getOffset();
                    TrailSystem.add(pos.x, CFG.HEIGHT - (pos.y - camOffset.y));
                    this.trailTimer = 0;
                }
            },

            startDeathAnimation() {
                this.deathAnimation = 0.01;

                // Create fragments (8 pieces)
                const pos = this.getWorldPos();
                const camOffset = Camera.getOffset();
                const centerX = pos.x;
                const centerY = CFG.HEIGHT - (pos.y - camOffset.y);

                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const speed = 3 + Math.random() * 2;
                    this.deathFragments.push({
                        x: centerX,
                        y: centerY,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 2,
                        rotation: Math.random() * Math.PI * 2,
                        rotSpeed: (Math.random() - 0.5) * 10,
                        size: 15 + Math.random() * 10,
                        alpha: 1,
                        color: CFG.COLORS.PLAYER[Math.floor(Math.random() * 3)]
                    });
                }
            },

            getWorldPos() {
                return {
                    x: (this.gridX - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2,
                    y: this.gridY * CFG.CELL_SIZE
                };
            }
        };

        const Camera = {
            y: 0,
            shakeAmount: 0,
            shakeX: 0,
            shakeY: 0,

            init() {
                this.y = Player.gridY - 5;
                this.shakeAmount = 0;
            },

            update(dt) {
                if (Game.state !== 'playing') return;

                // ðŸŽ¬ AUTO-SCROLL DOWN - Map scrolls downward automatically
                const targetY = Player.gridY + 5; // CHANGED: Look ahead DOWN
                this.y += (targetY - this.y) * 0.1;
                this.y -= CFG.CAMERA_SPEED * dt; // CHANGED: Scroll DOWN (negative)

                if (this.shakeAmount > 0) {
                    this.shakeAmount *= 0.86;
                    if (this.shakeAmount < 0.5) this.shakeAmount = 0;

                    this.shakeX = (Math.random() - 0.5) * this.shakeAmount;
                    this.shakeY = (Math.random() - 0.5) * this.shakeAmount;
                } else {
                    this.shakeX = 0;
                    this.shakeY = 0;
                }
            },

            shake(intensity = 15) {
                this.shakeAmount = Math.max(this.shakeAmount, intensity);
            },

            getOffset() {
                return {
                    x: this.shakeX,
                    y: this.y * CFG.CELL_SIZE + this.shakeY
                };
            }
        };

        const Entities = {
            coins: [],
            walls: [],
            movingWalls: [],
            turrets: [],
            lasers: [],
            projectiles: [],

            init() {
                this.coins = [];
                this.walls = [];
                this.movingWalls = [];
                this.turrets = [];
                this.lasers = [];
                this.projectiles = [];

                LEVEL.coins.forEach(c => {
                    this.coins.push({
                        x: c.x, y: c.y,
                        collected: false,
                        scale: 1,
                        alpha: 1,
                        rotation: Math.random() * Math.PI * 2,
                        bobOffset: Math.random() * Math.PI * 2
                    });
                });

                LEVEL.walls.forEach(w => {
                    this.walls.push({
                        x: w.x, y: w.y,
                        w: w.w || 1, h: w.h || 1,
                        active: true
                    });
                });

                // Initialize moving walls
                LEVEL.movingWalls.forEach(mw => {
                    this.movingWalls.push({
                        x: mw.x,
                        y: mw.y,
                        w: mw.w,
                        h: mw.h,
                        minX: mw.minX,
                        maxX: mw.maxX,
                        speed: mw.speed,
                        dir: mw.dir,
                        active: true
                    });
                });

                // Initialize turrets
                LEVEL.turrets.forEach(t => {
                    this.turrets.push({
                        x: t.x,
                        y: t.y,
                        shootDelay: t.shootDelay,
                        lastShot: t.lastShot,
                        charging: 0
                    });
                });

                // Initialize lasers
                LEVEL.lasers.forEach(l => {
                    this.lasers.push({
                        x: l.x,
                        y: l.y,
                        w: l.w,
                        h: l.h,
                        onTime: l.onTime,
                        offTime: l.offTime,
                        timer: 0,
                        active: l.active
                    });
                });
            },

            update(dt) {
                const time = performance.now() / 1000;

                // Update coins
                this.coins.forEach(coin => {
                    if (coin.collected) {
                        coin.scale += dt * 6;
                        coin.alpha -= dt * 2.2;
                    } else {
                        coin.scale = 1 + Math.sin(time * 4 + coin.bobOffset) * 0.2;
                        coin.rotation += dt * 2;
                    }
                });
                this.coins = this.coins.filter(c => !c.collected || c.alpha > 0);

                // Update moving walls
                this.movingWalls.forEach(mw => {
                    mw.x += mw.speed * mw.dir * dt;

                    // Bounce at boundaries
                    if (mw.x <= mw.minX) {
                        mw.x = mw.minX;
                        mw.dir = 1;
                    } else if (mw.x >= mw.maxX) {
                        mw.x = mw.maxX;
                        mw.dir = -1;
                    }
                });

                // Update turrets
                this.turrets.forEach(turret => {
                    turret.lastShot += dt;

                    // Charging animation
                    if (turret.lastShot >= turret.shootDelay - 0.5) {
                        turret.charging = Math.min(1, (turret.lastShot - (turret.shootDelay - 0.5)) / 0.5);
                    } else {
                        turret.charging = 0;
                    }

                    // Shoot projectile
                    if (turret.lastShot >= turret.shootDelay) {
                        turret.lastShot = 0;

                        // Calculate direction to player
                        const dx = Player.gridX - turret.x;
                        const dy = Player.gridY - turret.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist > 0) {
                            this.projectiles.push({
                                x: turret.x,
                                y: turret.y,
                                vx: (dx / dist) * 8,
                                vy: (dy / dist) * 8,
                                life: 0,
                                maxLife: 5
                            });

                            Camera.shake(5);
                        }
                    }
                });

                // Update lasers
                this.lasers.forEach(laser => {
                    laser.timer += dt;

                    const cycleTime = laser.onTime + laser.offTime;
                    const cyclePos = laser.timer % cycleTime;

                    laser.active = cyclePos < laser.onTime;
                });

                // Update projectiles
                this.projectiles = this.projectiles.filter(p => {
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.life += dt;

                    // Remove if out of bounds or too old
                    return p.life < p.maxLife &&
                           p.x >= -2 && p.x <= CFG.GRID_WIDTH + 2 &&
                           p.y >= -10 && p.y <= 100;
                });
            }
        };

        const Collision = {
            check() {
                if (Game.state !== 'playing') return;

                const px = Player.gridX;
                const py = Player.gridY;
                const pr = CFG.PLAYER_RADIUS;

                // Coin collection
                Entities.coins.forEach(coin => {
                    if (coin.collected) return;

                    const dx = px - coin.x;
                    const dy = py - coin.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < pr + CFG.COIN_RADIUS) {
                        this.collectCoin(coin);
                    }
                });

                // Static walls
                Entities.walls.forEach(wall => {
                    if (!wall.active) return;

                    const wallLeft = wall.x - wall.w / 2;
                    const wallRight = wall.x + wall.w / 2;
                    const wallTop = wall.y;
                    const wallBottom = wall.y + wall.h;

                    if (px + pr > wallLeft &&
                        px - pr < wallRight &&
                        py + pr > wallTop &&
                        py - pr < wallBottom) {
                        this.hitObstacle('wall');
                    }
                });

                // Moving walls
                Entities.movingWalls.forEach(mw => {
                    if (!mw.active) return;

                    const wallLeft = mw.x - mw.w / 2;
                    const wallRight = mw.x + mw.w / 2;
                    const wallTop = mw.y;
                    const wallBottom = mw.y + mw.h;

                    if (px + pr > wallLeft &&
                        px - pr < wallRight &&
                        py + pr > wallTop &&
                        py - pr < wallBottom) {
                        this.hitObstacle('moving wall');
                    }
                });

                // Projectiles
                Entities.projectiles.forEach(proj => {
                    const dx = px - proj.x;
                    const dy = py - proj.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < pr + 0.2) {
                        this.hitObstacle('projectile');
                    }
                });

                // Lasers (only when active)
                Entities.lasers.forEach(laser => {
                    if (!laser.active) return;

                    const laserLeft = laser.x;
                    const laserRight = laser.x + laser.w;
                    const laserTop = laser.y;
                    const laserBottom = laser.y + laser.h;

                    if (px + pr > laserLeft &&
                        px - pr < laserRight &&
                        py + pr > laserTop &&
                        py - pr < laserBottom) {
                        this.hitObstacle('laser');
                    }
                });
            },

            collectCoin(coin) {
                coin.collected = true;
                Game.score++;
                UI.addCoinFX(coin.x, coin.y);

                const worldX = (coin.x - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                const camOffset = Camera.getOffset();
                const screenY = CFG.HEIGHT - (coin.y * CFG.CELL_SIZE - camOffset.y);

                ParticleSystem.spawnBurst(worldX, screenY, 20, {
                    color: CFG.COLORS.COIN,
                    size: 7,
                    life: 1.2,
                    speed: 6,
                    spread: 3,
                    gravity: 0.2
                });

                Camera.shake(7);
            },

            hitObstacle(obstacleType) {
                if (Game.state !== 'playing') return;
                Game.state = 'gameover';
                Camera.shake(35);

                // Start death animation
                Player.startDeathAnimation();

                const pos = Player.getWorldPos();
                const camOffset = Camera.getOffset();

                // Massive particle explosion
                ParticleSystem.spawnBurst(
                    pos.x,
                    CFG.HEIGHT - (pos.y - camOffset.y),
                    50,
                    { color: CFG.COLORS.WALL, size: 8, life: 1.4, speed: 9, spread: 5, gravity: 0.25 }
                );

                // Secondary player-colored explosion
                ParticleSystem.spawnBurst(
                    pos.x,
                    CFG.HEIGHT - (pos.y - camOffset.y),
                    40,
                    { color: CFG.COLORS.PLAYER, size: 6, life: 1.2, speed: 7, spread: 4, gravity: 0.2 }
                );

                setTimeout(() => Game.showCTA(), 1200);
            }
        };

        const UI = {
            tutorialAlpha: 1,
            coinFX: [],

            addCoinFX(gridX, gridY) {
                const worldX = (gridX - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                const camOffset = Camera.getOffset();
                const screenY = CFG.HEIGHT - (gridY * CFG.CELL_SIZE - camOffset.y);

                this.coinFX.push({
                    x: worldX,
                    y: screenY,
                    alpha: 1,
                    scale: 0.3,
                    life: 0
                });
            },

            update(dt) {
                if (Game.state === 'playing' && this.tutorialAlpha > 0) {
                    this.tutorialAlpha = Math.max(0, this.tutorialAlpha - dt * CFG.TUTORIAL_FADE_SPEED);
                }

                this.coinFX = this.coinFX.filter(fx => {
                    fx.life += dt;
                    fx.y -= dt * 100;
                    fx.alpha = 1 - Easing.easeOutQuad(fx.life / 1);
                    fx.scale = 0.3 + Easing.easeOutBack(Math.min(fx.life / 0.4, 1)) * 0.9;
                    return fx.life < 1;
                });
            },

            draw(ctx) {
                // ðŸ’Ž PREMIUM GLASSMORPHISM HUD
                ctx.save();

                // ðŸŽ¨ GLASSMORPHISM SCORE PANEL
                const panelX = 25;
                const panelY = 25;
                const panelW = 180;
                const panelH = 85;
                const panelRadius = 20;

                // Frosted glass backdrop (simulated)
                const backdropGrad = ctx.createLinearGradient(panelX, panelY, panelX, panelY + panelH);
                backdropGrad.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
                backdropGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.10)');
                backdropGrad.addColorStop(1, 'rgba(255, 255, 255, 0.05)');

                ctx.fillStyle = backdropGrad;
                ctx.shadowBlur = 25;
                ctx.shadowColor = 'rgba(0, 255, 136, 0.4)';
                ctx.beginPath();
                ctx.roundRect(panelX, panelY, panelW, panelH, panelRadius);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Glass border (bright edge)
                const borderGrad = ctx.createLinearGradient(panelX, panelY, panelX, panelY + panelH);
                borderGrad.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                borderGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
                borderGrad.addColorStop(1, 'rgba(255, 255, 255, 0.1)');

                ctx.strokeStyle = borderGrad;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(panelX, panelY, panelW, panelH, panelRadius);
                ctx.stroke();

                // Inner glow
                ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.roundRect(panelX + 2, panelY + 2, panelW - 4, panelH - 4, panelRadius - 2);
                ctx.stroke();

                // Score text with premium styling
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(0, 255, 136, 0.9)';
                ctx.fillStyle = '#00ff88';
                ctx.font = '900 52px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(Game.score.toString(), panelX + 20, panelY + 60);

                // Coin icon with glow
                const iconSize = 42;
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#ffd700';
                ctx.drawImage(SpriteCache.coin, panelX + panelW - iconSize - 18, panelY + 22, iconSize, iconSize);
                ctx.shadowBlur = 0;

                ctx.restore();

                // ðŸ’Ž PREMIUM GLASSMORPHISM PROGRESS BAR
                const progress = Math.max(0, (CFG.GAME_DURATION - Game.elapsed) / CFG.GAME_DURATION);
                const barX = 25;
                const barY = 125;
                const barW = CFG.WIDTH - 50;
                const barH = 16;
                const barRadius = 10;

                // Glass container
                const barBgGrad = ctx.createLinearGradient(barX, barY, barX, barY + barH);
                barBgGrad.addColorStop(0, 'rgba(255, 255, 255, 0.12)');
                barBgGrad.addColorStop(1, 'rgba(255, 255, 255, 0.05)');

                ctx.fillStyle = barBgGrad;
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.roundRect(barX, barY, barW, barH, barRadius);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Glass border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.roundRect(barX, barY, barW, barH, barRadius);
                ctx.stroke();

                // Progress fill with animated gradient
                const time = performance.now() / 1000;
                const animOffset = (time % 2) * barW;

                ctx.save();
                ctx.beginPath();
                ctx.roundRect(barX + 2, barY + 2, barW - 4, barH - 4, barRadius - 2);
                ctx.clip();

                const progressGrad = ctx.createLinearGradient(barX + animOffset, 0, barX + animOffset + barW, 0);
                progressGrad.addColorStop(0, '#00ff88');
                progressGrad.addColorStop(0.25, '#00d4ff');
                progressGrad.addColorStop(0.5, '#a855f7');
                progressGrad.addColorStop(0.75, '#00d4ff');
                progressGrad.addColorStop(1, '#00ff88');

                ctx.fillStyle = progressGrad;
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(0, 255, 136, 0.8)';
                ctx.fillRect(barX + 2, barY + 2, (barW - 4) * progress, barH - 4);
                ctx.shadowBlur = 0;

                // Progress shine overlay
                const shineGrad = ctx.createLinearGradient(barX, barY, barX, barY + barH / 2);
                shineGrad.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                shineGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = shineGrad;
                ctx.fillRect(barX + 2, barY + 2, (barW - 4) * progress, (barH - 4) / 2);

                ctx.restore();

                // Coin FX with enhanced glow
                this.coinFX.forEach(fx => {
                    ctx.save();
                    ctx.globalAlpha = fx.alpha;

                    const textGradient = ctx.createLinearGradient(fx.x - 30, fx.y, fx.x + 30, fx.y);
                    textGradient.addColorStop(0, '#ffd700');
                    textGradient.addColorStop(0.5, '#fff');
                    textGradient.addColorStop(1, '#ffd700');

                    ctx.fillStyle = textGradient;
                    ctx.font = `900 ${32 * fx.scale}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 6;
                    ctx.shadowColor = '#ffd700';
                    ctx.strokeStyle = 'rgba(139, 105, 20, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.strokeText('+1', fx.x, fx.y);
                    ctx.fillText('+1', fx.x, fx.y);
                    ctx.restore();
                });

                // Tutorial with modern design
                if (this.tutorialAlpha > 0 && (Game.state === 'tutorial' || Game.state === 'loading')) {
                    this.drawTutorial(ctx);
                }
            },

            drawTutorial(ctx) {
                const alpha = this.tutorialAlpha;

                ctx.fillStyle = `rgba(0,0,0,${0.6 * alpha})`;
                ctx.fillRect(0, 0, CFG.WIDTH, CFG.HEIGHT);

                ctx.globalAlpha = alpha;

                // Modern title with gradient
                const titleGradient = ctx.createLinearGradient(0, CFG.HEIGHT / 2 - 90, 0, CFG.HEIGHT / 2 - 40);
                titleGradient.addColorStop(0, '#00ff88');
                titleGradient.addColorStop(0.5, '#00d4ff');
                titleGradient.addColorStop(1, '#a855f7');

                ctx.fillStyle = titleGradient;
                ctx.font = 'bold 44px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 212, 255, 0.9)';
                ctx.shadowBlur = 12;
                ctx.fillText('Swipe or Arrow Keys', CFG.WIDTH / 2, CFG.HEIGHT / 2 - 70);

                // Animated hand with glow
                const time = performance.now() / 1000;
                const handX = CFG.WIDTH / 2 + Math.sin(time * 2.5) * 70;
                const handY = CFG.HEIGHT / 2 + 30;

                ctx.strokeStyle = `rgba(255,255,255,${0.7 * alpha})`;
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.setLineDash([16, 12]);
                ctx.shadowBlur = 8;
                ctx.shadowColor = 'rgba(0, 212, 255, 0.8)';
                ctx.beginPath();
                ctx.moveTo(CFG.WIDTH / 2 - 80, handY);
                ctx.lineTo(CFG.WIDTH / 2 + 80, handY);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.font = '72px Arial';
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
                ctx.fillText('â˜ï¸', handX, handY + 15);

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        };

        const Render = {
            ctx: null,
            canvas: null,

            init() {
                this.canvas = document.getElementById('c');
                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.ctx = this.canvas.getContext('2d', { alpha: false, desynchronized: true });
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
            },

            resize() {
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                const gameAspect = CFG.WIDTH / CFG.HEIGHT; // 0.5625 (9:16)
                const windowAspect = vw / vh;

                let displayWidth, displayHeight;

                // Fill entire viewport while maintaining aspect ratio
                if (windowAspect < gameAspect) {
                    // Window is taller (more portrait) - fit to width
                    displayWidth = vw;
                    displayHeight = vw / gameAspect;
                } else {
                    // Window is wider (more landscape) - fit to height
                    displayHeight = vh;
                    displayWidth = vh * gameAspect;
                }

                // Set canvas display size
                this.canvas.style.width = displayWidth + 'px';
                this.canvas.style.height = displayHeight + 'px';

                // Set canvas buffer size
                const newWidth = CFG.WIDTH * CFG.PIXEL_RATIO;
                const newHeight = CFG.HEIGHT * CFG.PIXEL_RATIO;

                if (this.canvas.width !== newWidth || this.canvas.height !== newHeight) {
                    this.canvas.width = newWidth;
                    this.canvas.height = newHeight;

                    // Recreate context after canvas resize
                    this.ctx = this.canvas.getContext('2d', { alpha: false, desynchronized: true });
                    this.ctx.imageSmoothingEnabled = true;
                    this.ctx.imageSmoothingQuality = 'high';
                    this.ctx.scale(CFG.PIXEL_RATIO, CFG.PIXEL_RATIO);
                }
            },

            draw() {
                const ctx = this.ctx;
                const camOffset = Camera.getOffset();

                // Enhanced background with stars
                const bgGradient = ctx.createRadialGradient(CFG.WIDTH / 2, CFG.HEIGHT / 2, 0, CFG.WIDTH / 2, CFG.HEIGHT / 2, CFG.HEIGHT);
                bgGradient.addColorStop(0, CFG.COLORS.BG_MID);
                bgGradient.addColorStop(0.7, CFG.COLORS.BG_TOP);
                bgGradient.addColorStop(1, CFG.COLORS.BG_BOTTOM);
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, CFG.WIDTH, CFG.HEIGHT);

                // Animated stars
                const time = performance.now() / 1000;
                for (let i = 0; i < 15; i++) {
                    const x = (i * 73) % CFG.WIDTH;
                    const y = (i * 97 + camOffset.y * 0.3) % CFG.HEIGHT;
                    const size = 1 + (i % 3);
                    const twinkle = Math.sin(time * 2 + i) * 0.5 + 0.5;

                    ctx.globalAlpha = twinkle * 0.6;
                    ctx.fillStyle = i % 3 === 0 ? '#00d4ff' : '#fff';
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Modern grid
                ctx.strokeStyle = CFG.COLORS.GRID;
                ctx.lineWidth = 1.5;

                for (let i = 0; i <= CFG.GRID_WIDTH; i++) {
                    const x = (i - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, CFG.HEIGHT);
                    ctx.stroke();
                }

                const gridOffsetY = camOffset.y % CFG.CELL_SIZE;
                for (let i = -1; i <= CFG.HEIGHT / CFG.CELL_SIZE + 1; i++) {
                    const y = CFG.HEIGHT - i * CFG.CELL_SIZE + gridOffsetY;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(CFG.WIDTH, y);
                    ctx.stroke();
                }

                ctx.save();
                ctx.translate(camOffset.x, 0);

                this.drawShadows(ctx, camOffset);
                this.drawLasers(ctx, camOffset);
                this.drawWalls(ctx, camOffset);
                this.drawMovingWalls(ctx, camOffset);
                this.drawTurrets(ctx, camOffset);
                this.drawProjectiles(ctx, camOffset);
                this.drawCoins(ctx, camOffset);
                TrailSystem.draw(ctx);
                this.drawPlayer(ctx, camOffset);

                ctx.restore();

                ParticleSystem.draw(ctx);
                UI.draw(ctx);
            },

            drawShadows(ctx, camOffset) {
                const pos = Player.getWorldPos();
                const shadowSize = CFG.CELL_SIZE * 0.85 * 1.2;
                const shadowY = CFG.HEIGHT - (pos.y - camOffset.y) + CFG.CELL_SIZE * 0.35;

                ctx.globalAlpha = 0.4;
                ctx.drawImage(
                    SpriteCache.playerShadow,
                    pos.x - shadowSize / 2,
                    shadowY - shadowSize / 4,
                    shadowSize,
                    shadowSize / 2
                );

                Entities.coins.forEach(coin => {
                    if (coin.collected) return;
                    const screenY = CFG.HEIGHT - (coin.y * CFG.CELL_SIZE - camOffset.y);
                    if (screenY < -CFG.CELL_SIZE || screenY > CFG.HEIGHT + CFG.CELL_SIZE) return;

                    const x = (coin.x - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                    const size = CFG.CELL_SIZE * 0.55;

                    ctx.drawImage(
                        SpriteCache.coinShadow,
                        x - size / 2,
                        screenY + CFG.CELL_SIZE * 0.18,
                        size,
                        size / 2
                    );
                });

                ctx.globalAlpha = 1;
            },

            drawWalls(ctx, camOffset) {
                Entities.walls.forEach(wall => {
                    const screenY = CFG.HEIGHT - (wall.y * CFG.CELL_SIZE - camOffset.y);
                    if (screenY < -CFG.CELL_SIZE * 2 || screenY > CFG.HEIGHT + CFG.CELL_SIZE * 2) return;

                    const x = (wall.x - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                    const y = wall.y * CFG.CELL_SIZE;
                    const w = wall.w * CFG.CELL_SIZE;
                    const h = wall.h * CFG.CELL_SIZE;
                    const drawY = CFG.HEIGHT - (y - camOffset.y);

                    // ðŸŽ® TRUE ISOMETRIC 3D CUBE - Each wall is a real 3D box
                    const depth = 35; // 3D depth
                    const isoX = depth * 0.866; // cos(30Â°) * depth
                    const isoY = depth * 0.5;   // sin(30Â°) * depth

                    ctx.save();

                    // ðŸ“¦ STEP 1: DRAW RIGHT SIDE FACE (darkest)
                    ctx.beginPath();
                    const rightX1 = x + w / 2;
                    const rightY1 = drawY - h;
                    ctx.moveTo(rightX1, rightY1);
                    ctx.lineTo(rightX1 + isoX, rightY1 - isoY);
                    ctx.lineTo(rightX1 + isoX, drawY - isoY);
                    ctx.lineTo(rightX1, drawY);
                    ctx.closePath();

                    // Right side gradient (darker, it's in shadow)
                    const rightGrad = ctx.createLinearGradient(rightX1, rightY1, rightX1 + isoX, rightY1);
                    rightGrad.addColorStop(0, CFG.COLORS.WALL[2]); // Darkest
                    rightGrad.addColorStop(0.5, '#8b1530');
                    rightGrad.addColorStop(1, '#6b0f20');
                    ctx.fillStyle = rightGrad;
                    ctx.fill();

                    // Right side texture overlay
                    for (let ty = 0; ty < h; ty += 8) {
                        const noiseVal = TextureGen.noise2D(wall.x * 10, (wall.y + ty / h) * 10, 42);
                        if (noiseVal > 0.5) {
                            ctx.fillStyle = `rgba(0, 0, 0, ${0.15 * (noiseVal - 0.5)})`;
                            const py1 = rightY1 + ty;
                            const py2 = py1 + 8;
                            ctx.beginPath();
                            ctx.moveTo(rightX1, py1);
                            ctx.lineTo(rightX1 + isoX, py1 - isoY);
                            ctx.lineTo(rightX1 + isoX, py2 - isoY);
                            ctx.lineTo(rightX1, py2);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }

                    // ðŸ“¦ STEP 2: DRAW TOP FACE (medium brightness)
                    ctx.beginPath();
                    const topX1 = x - w / 2;
                    const topY1 = drawY - h;
                    ctx.moveTo(topX1, topY1);
                    ctx.lineTo(topX1 + isoX, topY1 - isoY);
                    ctx.lineTo(topX1 + w + isoX, topY1 - isoY);
                    ctx.lineTo(topX1 + w, topY1);
                    ctx.closePath();

                    // Top face gradient (medium brightness, receives some light)
                    const topGrad = ctx.createLinearGradient(topX1, topY1, topX1 + w, topY1);
                    topGrad.addColorStop(0, '#ff6b8a');
                    topGrad.addColorStop(0.3, CFG.COLORS.WALL[0]);
                    topGrad.addColorStop(0.7, CFG.COLORS.WALL[1]);
                    topGrad.addColorStop(1, '#ff5577');
                    ctx.fillStyle = topGrad;
                    ctx.fill();

                    // Top face texture (lighter, more visible)
                    for (let tx = 0; tx < w; tx += 10) {
                        const noiseVal = TextureGen.fractalNoise((wall.x + tx / w) * 5, wall.y * 5, 3, 0.5, 2, 123);
                        if (noiseVal > 0.4) {
                            ctx.fillStyle = `rgba(255, 255, 255, ${0.1 * (noiseVal - 0.4)})`;
                            const px1 = topX1 + tx;
                            const px2 = px1 + 10;
                            ctx.beginPath();
                            ctx.moveTo(px1, topY1);
                            ctx.lineTo(px1 + isoX, topY1 - isoY);
                            ctx.lineTo(px2 + isoX, topY1 - isoY);
                            ctx.lineTo(px2, topY1);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }

                    // Top edge highlight
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(topX1, topY1);
                    ctx.lineTo(topX1 + isoX, topY1 - isoY);
                    ctx.lineTo(topX1 + w + isoX, topY1 - isoY);
                    ctx.lineTo(topX1 + w, topY1);
                    ctx.stroke();

                    // ðŸ“¦ STEP 3: DRAW FRONT FACE (brightest, main face)
                    const frontX = x - w / 2;
                    const frontY = drawY - h;
                    const frontW = w;
                    const frontH = h;

                    // Front face shadow (contact shadow at bottom)
                    const shadowGrad = ctx.createLinearGradient(frontX, drawY - 30, frontX, drawY);
                    shadowGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
                    shadowGrad.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
                    ctx.fillStyle = shadowGrad;
                    ctx.fillRect(frontX, drawY - 30, frontW, 30);

                    // Main front face - PREMIUM GRADIENT
                    const frontGrad = ctx.createLinearGradient(frontX, frontY, frontX, frontY + frontH);
                    frontGrad.addColorStop(0, CFG.COLORS.WALL[1]);
                    frontGrad.addColorStop(0.2, CFG.COLORS.WALL[0]); // Brightest at top
                    frontGrad.addColorStop(0.5, CFG.COLORS.WALL[0]);
                    frontGrad.addColorStop(0.8, CFG.COLORS.WALL[1]);
                    frontGrad.addColorStop(1, CFG.COLORS.WALL[2]);

                    ctx.fillStyle = frontGrad;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(255, 51, 102, 0.8)';
                    ctx.fillRect(frontX + 3, frontY + 3, frontW - 6, frontH - 6);
                    ctx.shadowBlur = 0;

                    // ðŸ§± PREMIUM BRICK TEXTURE on front face
                    const brickH = 18;
                    const brickW = 40;
                    const mortarSize = 2;

                    for (let by = 0; by < frontH; by += brickH) {
                        const row = Math.floor(by / brickH);
                        const rowOffset = (row % 2) * (brickW / 2);

                        for (let bx = -brickW; bx < frontW + brickW; bx += brickW) {
                            const brickX = frontX + bx + rowOffset;
                            const brickY = frontY + by;

                            // Skip if outside wall
                            if (brickX + brickW < frontX || brickX > frontX + frontW) continue;

                            // Brick base with noise
                            const noise = TextureGen.fractalNoise(
                                (brickX + brickY) / 30,
                                brickY / 30,
                                4, 0.6, 3, wall.x * 7 + wall.y * 11
                            );

                            // Brick color variation
                            const brickDark = Math.floor((noise - 0.5) * 40);
                            ctx.fillStyle = `rgba(${200 + brickDark}, ${40 + brickDark}, ${60 + brickDark}, 0.3)`;
                            ctx.fillRect(
                                Math.max(brickX + mortarSize, frontX),
                                brickY + mortarSize,
                                Math.min(brickW - mortarSize * 2, frontX + frontW - brickX - mortarSize),
                                brickH - mortarSize * 2
                            );

                            // Brick highlight (top edge)
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
                            ctx.fillRect(
                                Math.max(brickX + mortarSize, frontX),
                                brickY + mortarSize,
                                Math.min(brickW - mortarSize * 2, frontX + frontW - brickX - mortarSize),
                                2
                            );

                            // Brick shadow (bottom edge)
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                            ctx.fillRect(
                                Math.max(brickX + mortarSize, frontX),
                                brickY + brickH - mortarSize - 1,
                                Math.min(brickW - mortarSize * 2, frontX + frontW - brickX - mortarSize),
                                1
                            );
                        }
                    }

                    // Front face edge glow
                    ctx.strokeStyle = 'rgba(255, 100, 130, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(frontX + 2, frontY + 2, frontW - 4, frontH - 4);

                    // Inner edge shadow for depth
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(frontX + 4, frontY + 4, frontW - 8, frontH - 8);

                    ctx.restore();
                });
                ctx.shadowBlur = 0;
            },

            drawMovingWalls(ctx, camOffset) {
                // Render moving walls with same 3D isometric style as static walls
                Entities.movingWalls.forEach(wall => {
                    if (!wall.active) return;

                    const screenY = CFG.HEIGHT - (wall.y * CFG.CELL_SIZE - camOffset.y);
                    if (screenY < -CFG.CELL_SIZE * 2 || screenY > CFG.HEIGHT + CFG.CELL_SIZE * 2) return;

                    const x = (wall.x - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                    const y = wall.y * CFG.CELL_SIZE;
                    const w = wall.w * CFG.CELL_SIZE;
                    const h = wall.h * CFG.CELL_SIZE;
                    const drawY = CFG.HEIGHT - (y - camOffset.y);

                    const depth = 35;
                    const isoX = depth * 0.866;
                    const isoY = depth * 0.5;

                    ctx.save();

                    // Right side face (orange tint for moving walls)
                    ctx.beginPath();
                    const rightX1 = x + w / 2;
                    const rightY1 = drawY - h;
                    ctx.moveTo(rightX1, rightY1);
                    ctx.lineTo(rightX1 + isoX, rightY1 - isoY);
                    ctx.lineTo(rightX1 + isoX, drawY - isoY);
                    ctx.lineTo(rightX1, drawY);
                    ctx.closePath();

                    const rightGrad = ctx.createLinearGradient(rightX1, rightY1, rightX1 + isoX, rightY1);
                    rightGrad.addColorStop(0, '#cc6600');
                    rightGrad.addColorStop(1, '#883300');
                    ctx.fillStyle = rightGrad;
                    ctx.fill();

                    // Top face
                    ctx.beginPath();
                    const topX1 = x - w / 2;
                    const topY1 = drawY - h;
                    ctx.moveTo(topX1, topY1);
                    ctx.lineTo(topX1 + isoX, topY1 - isoY);
                    ctx.lineTo(topX1 + w + isoX, topY1 - isoY);
                    ctx.lineTo(topX1 + w, topY1);
                    ctx.closePath();

                    const topGrad = ctx.createLinearGradient(topX1, topY1 - isoY, topX1 + w, topY1);
                    topGrad.addColorStop(0, '#ff9933');
                    topGrad.addColorStop(1, '#ff7700');
                    ctx.fillStyle = topGrad;
                    ctx.fill();

                    // Front face (brightest)
                    const frontX = x - w / 2;
                    const frontY = drawY - h;
                    const frontW = w;
                    const frontH = h;

                    const frontGrad = ctx.createLinearGradient(frontX, frontY, frontX, drawY);
                    frontGrad.addColorStop(0, '#ffaa55');
                    frontGrad.addColorStop(1, '#ff8833');
                    ctx.fillStyle = frontGrad;
                    ctx.fillRect(frontX, frontY, frontW, frontH);

                    // Glowing edge to indicate movement
                    ctx.strokeStyle = 'rgba(255, 200, 100, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(frontX, frontY, frontW, frontH);

                    ctx.restore();
                });
            },

            drawTurrets(ctx, camOffset) {
                const time = performance.now() / 1000;

                Entities.turrets.forEach(turret => {
                    const screenY = CFG.HEIGHT - (turret.y * CFG.CELL_SIZE - camOffset.y);
                    if (screenY < -CFG.CELL_SIZE || screenY > CFG.HEIGHT + CFG.CELL_SIZE) return;

                    const x = (turret.x - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                    const y = CFG.HEIGHT - (turret.y * CFG.CELL_SIZE - camOffset.y);

                    const size = CFG.CELL_SIZE * 0.7;

                    ctx.save();
                    ctx.translate(x, y);

                    // Charging glow effect
                    if (turret.charging > 0) {
                        const glowSize = size * (1 + turret.charging * 0.5);
                        const glowGrad = ctx.createRadialGradient(0, 0, size * 0.3, 0, 0, glowSize);
                        glowGrad.addColorStop(0, `rgba(255, 50, 50, ${turret.charging * 0.6})`);
                        glowGrad.addColorStop(1, 'rgba(255, 50, 50, 0)');
                        ctx.fillStyle = glowGrad;
                        ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
                    }

                    // Turret base
                    const baseGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.5);
                    baseGrad.addColorStop(0, '#666666');
                    baseGrad.addColorStop(0.7, '#333333');
                    baseGrad.addColorStop(1, '#111111');
                    ctx.fillStyle = baseGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2);
                    ctx.fill();

                    // Turret barrel pointing at player
                    const dx = Player.gridX - turret.x;
                    const dy = Player.gridY - turret.y;
                    const angle = Math.atan2(dy, dx);

                    ctx.rotate(angle);

                    // Barrel
                    const barrelGrad = ctx.createLinearGradient(0, -size * 0.15, 0, size * 0.15);
                    barrelGrad.addColorStop(0, '#444444');
                    barrelGrad.addColorStop(0.5, '#222222');
                    barrelGrad.addColorStop(1, '#444444');
                    ctx.fillStyle = barrelGrad;
                    ctx.fillRect(0, -size * 0.15, size * 0.5, size * 0.3);

                    // Muzzle
                    ctx.fillStyle = turret.charging > 0.5 ? '#ff3333' : '#000000';
                    ctx.beginPath();
                    ctx.arc(size * 0.5, 0, size * 0.12, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                });
            },

            drawProjectiles(ctx, camOffset) {
                Entities.projectiles.forEach(proj => {
                    const screenY = CFG.HEIGHT - (proj.y * CFG.CELL_SIZE - camOffset.y);
                    if (screenY < -CFG.CELL_SIZE || screenY > CFG.HEIGHT + CFG.CELL_SIZE) return;

                    const x = (proj.x - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                    const y = CFG.HEIGHT - (proj.y * CFG.CELL_SIZE - camOffset.y);

                    const size = CFG.CELL_SIZE * 0.3;

                    ctx.save();
                    ctx.translate(x, y);

                    // Outer glow
                    const glowGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 1.5);
                    glowGrad.addColorStop(0, 'rgba(255, 100, 100, 0.8)');
                    glowGrad.addColorStop(0.5, 'rgba(255, 50, 50, 0.4)');
                    glowGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = glowGrad;
                    ctx.fillRect(-size * 1.5, -size * 1.5, size * 3, size * 3);

                    // Core projectile
                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.6);
                    coreGrad.addColorStop(0, '#ffff00');
                    coreGrad.addColorStop(0.5, '#ff8800');
                    coreGrad.addColorStop(1, '#ff0000');
                    ctx.fillStyle = coreGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.6, 0, Math.PI * 2);
                    ctx.fill();

                    // Bright core
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, -size * 0.15, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                });
            },

            drawLasers(ctx, camOffset) {
                const time = performance.now() / 1000;

                Entities.lasers.forEach(laser => {
                    const screenY = CFG.HEIGHT - (laser.y * CFG.CELL_SIZE - camOffset.y);
                    if (screenY < -CFG.CELL_SIZE || screenY > CFG.HEIGHT + CFG.CELL_SIZE) return;

                    const x = (laser.x - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                    const y = laser.y * CFG.CELL_SIZE;
                    const w = laser.w * CFG.CELL_SIZE;
                    const h = laser.h * CFG.CELL_SIZE;
                    const drawY = CFG.HEIGHT - (y - camOffset.y);

                    ctx.save();

                    if (laser.active) {
                        // Active laser - deadly red beam
                        const alpha = 0.8 + Math.sin(time * 20) * 0.2;

                        // Outer glow
                        const glowGrad = ctx.createLinearGradient(x, drawY - h * 3, x, drawY + h * 3);
                        glowGrad.addColorStop(0, 'rgba(255, 0, 0, 0)');
                        glowGrad.addColorStop(0.5, `rgba(255, 0, 0, ${alpha * 0.3})`);
                        glowGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        ctx.fillStyle = glowGrad;
                        ctx.fillRect(x, drawY - h * 3, w, h * 6);

                        // Core beam
                        const beamGrad = ctx.createLinearGradient(x, drawY - h, x, drawY + h);
                        beamGrad.addColorStop(0, 'rgba(255, 255, 255, 0)');
                        beamGrad.addColorStop(0.5, `rgba(255, 255, 255, ${alpha})`);
                        beamGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        ctx.fillStyle = beamGrad;
                        ctx.fillRect(x, drawY - h, w, h * 2);

                        // Bright center line
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.fillRect(x, drawY - h / 2, w, h);
                    } else {
                        // Inactive - warning indicators
                        const cycleTime = laser.onTime + laser.offTime;
                        const cyclePos = laser.timer % cycleTime;
                        const timeUntilActive = laser.onTime + laser.offTime - cyclePos;

                        // Blinking warning dots
                        if (Math.floor(time * 4) % 2 === 0) {
                            ctx.fillStyle = 'rgba(255, 100, 100, 0.5)';
                            const dotSize = CFG.CELL_SIZE * 0.15;
                            for (let i = 0; i < laser.w; i += 0.5) {
                                const dotX = (laser.x + i - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                                ctx.beginPath();
                                ctx.arc(dotX, drawY, dotSize, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    }

                    ctx.restore();
                });
            },

            drawCoins(ctx, camOffset) {
                Entities.coins.forEach(coin => {
                    const screenY = CFG.HEIGHT - (coin.y * CFG.CELL_SIZE - camOffset.y);
                    if (screenY < -CFG.CELL_SIZE || screenY > CFG.HEIGHT + CFG.CELL_SIZE) return;

                    const x = (coin.x - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                    const y = coin.y * CFG.CELL_SIZE;
                    const size = CFG.CELL_SIZE * 0.55 * coin.scale;

                    ctx.globalAlpha = coin.alpha;

                    if (!coin.collected) {
                        ctx.shadowColor = '#ffd700';
                        ctx.shadowBlur = 12;
                    }

                    ctx.save();
                    ctx.translate(x, CFG.HEIGHT - (y - camOffset.y));
                    ctx.rotate(coin.rotation);
                    ctx.drawImage(SpriteCache.coin, -size / 2, -size / 2, size, size);
                    ctx.restore();

                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                });
            },

            drawPlayer(ctx, camOffset) {
                // Draw death fragments if animating
                if (Player.deathAnimation > 0) {
                    Player.deathFragments.forEach(frag => {
                        ctx.save();
                        ctx.globalAlpha = frag.alpha;
                        ctx.translate(frag.x, frag.y);
                        ctx.rotate(frag.rotation);

                        // 3D fragment with gradient
                        const fragGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, frag.size);
                        fragGrad.addColorStop(0, frag.color);
                        fragGrad.addColorStop(0.7, frag.color + 'aa');
                        fragGrad.addColorStop(1, frag.color + '00');

                        ctx.fillStyle = fragGrad;
                        ctx.shadowColor = frag.color;
                        ctx.shadowBlur = 12;

                        // Draw irregular polygon fragment
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const angle = (i / 5) * Math.PI * 2;
                            const r = frag.size * (0.7 + Math.random() * 0.3);
                            const x = Math.cos(angle) * r;
                            const y = Math.sin(angle) * r;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();

                        ctx.restore();
                    });
                    return;
                }

                const pos = Player.getWorldPos();
                const size = CFG.CELL_SIZE * 0.85;

                let scaleX = 1;
                let scaleY = 1;
                if (Player.squashTime > 0) {
                    const t = Player.squashTime / 0.15;
                    if (Player.direction.x !== 0) {
                        scaleX = 1 - t * 0.35;
                        scaleY = 1 + t * 0.25;
                    } else {
                        scaleX = 1 + t * 0.25;
                        scaleY = 1 - t * 0.35;
                    }
                }

                const drawX = pos.x;
                const drawY = CFG.HEIGHT - (pos.y - camOffset.y);

                ctx.save();
                ctx.translate(drawX, drawY);
                ctx.rotate(Player.rotation); // ðŸŽ¾ ROLLING ANIMATION
                ctx.scale(scaleX, scaleY);

                ctx.shadowColor = '#00d4ff';
                ctx.shadowBlur = 16;

                ctx.drawImage(SpriteCache.player, -size / 2, -size / 2, size, size);

                ctx.restore();
            }
        };

        const Game = {
            state: 'loading',
            score: 0,
            elapsed: 0,
            lastTime: 0,

            async init() {
                await this.loadAssets();

                SpriteCache.init();
                ParticleSystem.init();
                Render.init();
                Input.init();
                Player.init();
                Camera.init();
                Entities.init();

                this.state = 'tutorial';
                this.score = 0;
                this.elapsed = 0;
                this.lastTime = performance.now();

                document.getElementById('loader').classList.add('hidden');

                requestAnimationFrame(this.loop.bind(this));
            },

            async loadAssets() {
                return new Promise(resolve => {
                    let progress = 0;
                    const interval = setInterval(() => {
                        progress += Math.random() * 0.2 + 0.05;
                        if (progress >= 1) {
                            progress = 1;
                            clearInterval(interval);
                            setTimeout(resolve, 300);
                        }
                        document.getElementById('progress').style.width = (progress * 100) + '%';
                    }, 100);
                });
            },

            startPlaying() {
                this.state = 'playing';
                this.elapsed = 0;
            },

            showCTA() {
                this.state = 'cta';
                document.getElementById('final-score').textContent = this.score;
                document.getElementById('cta').style.display = 'flex';
            },

            loop(time) {
                const dt = Math.min((time - this.lastTime) / 1000, 0.1);
                this.lastTime = time;

                if (this.state === 'playing') {
                    this.elapsed += dt * 1000;

                    if (this.elapsed >= CFG.GAME_DURATION) {
                        this.state = 'success';
                        setTimeout(() => this.showCTA(), 1500);
                    }
                }

                Player.update(dt);
                Camera.update(dt);
                Entities.update(dt);
                ParticleSystem.update(dt);
                TrailSystem.update(dt);
                UI.update(dt);
                Collision.check();

                Render.draw();

                if (this.state !== 'cta') {
                    requestAnimationFrame(this.loop.bind(this));
                }
            }
        };

        window.handleCTA = function() {
            const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            const url = isIOS ? CFG.IOS_URL : CFG.ANDROID_URL;

            if (typeof mraid !== 'undefined' && mraid.open) {
                mraid.open(url);
            } else {
                window.open(url, '_blank');
            }
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => Game.init());
        } else {
            Game.init();
        }
    })();
    </script>
</body>
</html>
